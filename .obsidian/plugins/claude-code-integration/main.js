/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => ClaudeCodePlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian4 = require("obsidian");

// src/ui/view.ts
var import_obsidian2 = require("obsidian");

// src/core/types.ts
var VIEW_TYPE_CLAUDE_CODE = "claude-code-view";

// src/i18n/locales/en.ts
var en = {
  // Header
  "header.title": "Claude Code assistant",
  "header.noNoteSelected": "no note selected",
  // Input Section
  "input.label": "Your instructions:",
  "input.placeholder": 'e.g., "Add more examples to this section" or "Reorganize with better headers" (Enter to send, Ctrl+Enter for new line)',
  "input.conversationalMode": "conversational mode (no file edits)",
  "input.conversationalModeTooltip": "Chat with Claude without modifying any files",
  "input.selectedTextOnly": "Edit selected text only",
  "input.autoAccept": "Auto-accept changes",
  "input.modelLabel": "Model:",
  "input.modelDefault": "Default",
  "input.runButton": "Run Claude Code",
  "input.runningButton": "Running...",
  "input.cancelButton": "Cancel",
  // Result Section
  "result.title": "Result",
  // Output Section
  "output.title": "Output",
  // Preview Section
  "preview.title": "Preview",
  "preview.tabRaw": "Raw",
  "preview.tabDiff": "Diff",
  "preview.tabRendered": "Rendered",
  "preview.originalChars": "Original:",
  "preview.modifiedChars": "Modified:",
  "preview.chars": "chars",
  "preview.applyButton": "apply changes",
  "preview.rejectButton": "reject",
  // History Section
  "history.title": "History",
  "history.clearButton": "Clear",
  // Agent Section
  "agent.planTitle": "plan",
  "agent.activityTitle": "Activity",
  "agent.noPlan": "No plan created yet",
  // Todo Status
  "todo.pending": "pending",
  "todo.inProgress": "in progress",
  "todo.completed": "completed",
  // Interactive Prompt
  "interactive.header": "Claude is asking for confirmation",
  "interactive.yesButton": "yes",
  "interactive.noButton": "no",
  "interactive.customPlaceholder": "Or type a custom response...",
  // Permission Approval
  "permission.header": "permission required",
  "permission.message": "Claude is requesting permission to execute actions.",
  "permission.approveButton": "approve & continue",
  "permission.denyButton": "deny",
  // Status Messages
  "status.processing": "Claude is processing",
  "status.autoApplying": "Auto-applying changes...",
  "status.runningAuthorized": "Running authorized tasks",
  "status.runningInBackground": "Running in background...",
  "status.failed": "Failed - see error below",
  // Notifications
  "notice.alreadyProcessing": "Already processing a request. Please wait.",
  "notice.enterPrompt": "Please enter a prompt",
  "notice.noActiveNote": "No active note found, please open a Markdown note first",
  "notice.noEditor": "No Markdown editor found, please make sure you have a note open",
  "notice.noVaultPath": "Could not determine vault path",
  "notice.completed": "Claude Code completed",
  "notice.completedNoChanges": "Claude Code completed (no file changes)",
  "notice.changesApplied": "changes applied automatically",
  "notice.changesAppliedSuccess": "changes applied successfully",
  "notice.failedApplyChanges": "failed to apply changes",
  "notice.changesRejected": "Changes rejected",
  "notice.cancelled": "Cancelled",
  "notice.permissionRequest": "Claude is requesting permission - please approve or deny",
  "notice.permissionDenied": "Permission denied - Claude will not proceed",
  "notice.noChangesToApply": "no changes to apply",
  "notice.noActiveFile": "no active file",
  "notice.historyRestored": "History item restored",
  "notice.historyRestoredWithChanges": "History item restored with proposed changes",
  "notice.historyCleared": "History cleared",
  // Diff View
  "diff.original": "Original",
  "diff.modified": "Modified",
  // Result Renderer
  "result.directAnswer": "Direct answer",
  "result.additionalContext": "Additional Context",
  "result.tokens": "tokens",
  "result.tokensIn": "in",
  "result.tokensOut": "out",
  // Preview Stats
  "preview.originalLabel": "Original:",
  "preview.modifiedLabel": "Modified:",
  "preview.charsLabel": "chars",
  // Misc
  "misc.noPendingRequest": "No pending request found",
  "misc.languageChanged": "Language changed. Some UI elements will update on reload.",
  "misc.testFailed": "Claude Code test failed",
  // Settings
  "settings.autoDetectPath": "Auto-detect Claude Code path",
  "settings.autoDetectPathDesc": "Automatically detect the Claude Code executable location",
  "settings.executablePath": "Claude Code executable path",
  "settings.executablePathDesc": "Full path to the Claude Code executable (e.g., /usr/local/bin/claude)",
  "settings.testInstallation": "Test Claude Code installation",
  "settings.testInstallationDesc": "Verify that Claude Code is accessible and working",
  "settings.testButton": "Test",
  "settings.testWorking": "working!",
  "settings.testFailed": "failed",
  "settings.customPrompt": "Custom system prompt",
  "settings.customPromptDesc": "Optional custom system prompt to prepend to all requests",
  "settings.customPromptPlaceholder": "You are helping edit markdown notes...",
  "settings.preserveCursor": "Preserve cursor position",
  "settings.preserveCursorDesc": "Try to maintain cursor position after applying changes",
  "settings.autoAcceptChanges": "Auto-accept changes",
  "settings.autoAcceptChangesDesc": "Automatically apply changes without showing preview (use with caution!)",
  "settings.model": "Model",
  "settings.modelDesc": "Select the Claude model to use: Sonnet (balanced), Opus (most capable), or Haiku (fastest). Leave empty to use the default subagent model.",
  "settings.modelDefault": "Default (subagent model)",
  "settings.modelSonnet": "Sonnet (balanced)",
  "settings.modelOpus": "Opus (most capable)",
  "settings.modelHaiku": "Haiku (fastest)",
  "settings.vaultAccess": "Allow vault-wide access",
  "settings.vaultAccessDesc": "Allow Claude to read/search other files in your vault (not just the current note)",
  "settings.permissionlessMode": "Enable permissionless mode",
  "settings.permissionlessModeDesc": "Allow Claude to execute actions without asking for permission each time (use with caution! Claude will have full control)",
  "settings.timeout": "Timeout (seconds)",
  "settings.timeoutDesc": "Maximum time to wait for Claude Code response (0 = no timeout)",
  "settings.customApiConfig": "Custom API configuration",
  "settings.customApiConfigDesc": "Configure custom API endpoints for regions where Claude is not directly available. Leave empty to use default settings.",
  "settings.apiBaseUrl": "API base URL",
  "settings.apiBaseUrlDesc": "Custom API endpoint URL (e.g., https://api.kimi.com/coding/)",
  "settings.apiAuthToken": "API auth token",
  "settings.apiAuthTokenDesc": "Custom authentication token for the API endpoint",
  "settings.apiAuthTokenPlaceholder": "Enter your API token",
  "settings.customModel": "Custom model",
  "settings.customModelDesc": "Custom model name to use (e.g., kimi-for-coding). Overrides the model dropdown above.",
  "settings.customSmallModel": "Custom small/fast model",
  "settings.customSmallModelDesc": "Custom model name for fast operations (e.g., kimi-for-coding)",
  "settings.language": "Language",
  "settings.languageDesc": "Select interface language"
};

// src/i18n/locales/zh.ts
var zh = {
  // Header
  "header.title": "Claude Code \u52A9\u624B",
  "header.noNoteSelected": "\u672A\u9009\u62E9\u7B14\u8BB0",
  // Input Section
  "input.label": "\u8F93\u5165\u6307\u4EE4\uFF1A",
  "input.placeholder": '\u4F8B\u5982\uFF1A"\u4E3A\u8FD9\u4E2A\u90E8\u5206\u6DFB\u52A0\u66F4\u591A\u793A\u4F8B" \u6216 "\u7528\u66F4\u597D\u7684\u6807\u9898\u91CD\u65B0\u7EC4\u7EC7"\uFF08\u56DE\u8F66\u53D1\u9001\uFF0CCtrl+\u56DE\u8F66\u6362\u884C\uFF09',
  "input.conversationalMode": "\u5BF9\u8BDD\u6A21\u5F0F\uFF08\u4E0D\u4FEE\u6539\u6587\u4EF6\uFF09",
  "input.conversationalModeTooltip": "\u4E0E Claude \u5BF9\u8BDD\u4F46\u4E0D\u4FEE\u6539\u4EFB\u4F55\u6587\u4EF6",
  "input.selectedTextOnly": "\u4EC5\u7F16\u8F91\u9009\u4E2D\u6587\u672C",
  "input.autoAccept": "\u81EA\u52A8\u5E94\u7528\u66F4\u6539",
  "input.modelLabel": "\u6A21\u578B\uFF1A",
  "input.modelDefault": "\u9ED8\u8BA4",
  "input.runButton": "\u8FD0\u884C Claude Code",
  "input.runningButton": "\u8FD0\u884C\u4E2D...",
  "input.cancelButton": "\u53D6\u6D88",
  // Result Section
  "result.title": "\u7ED3\u679C",
  // Output Section
  "output.title": "\u8F93\u51FA",
  // Preview Section
  "preview.title": "\u9884\u89C8",
  "preview.tabRaw": "\u539F\u59CB",
  "preview.tabDiff": "\u5DEE\u5F02",
  "preview.tabRendered": "\u6E32\u67D3",
  "preview.originalChars": "\u539F\u59CB\uFF1A",
  "preview.modifiedChars": "\u4FEE\u6539\u540E\uFF1A",
  "preview.chars": "\u5B57\u7B26",
  "preview.applyButton": "\u5E94\u7528\u66F4\u6539",
  "preview.rejectButton": "\u62D2\u7EDD",
  // History Section
  "history.title": "\u5386\u53F2\u8BB0\u5F55",
  "history.clearButton": "\u6E05\u9664",
  // Agent Section
  "agent.planTitle": "\u8BA1\u5212",
  "agent.activityTitle": "\u6D3B\u52A8",
  "agent.noPlan": "\u5C1A\u672A\u521B\u5EFA\u8BA1\u5212",
  // Todo Status
  "todo.pending": "\u5F85\u5904\u7406",
  "todo.inProgress": "\u8FDB\u884C\u4E2D",
  "todo.completed": "\u5DF2\u5B8C\u6210",
  // Interactive Prompt
  "interactive.header": "Claude \u6B63\u5728\u8BF7\u6C42\u786E\u8BA4",
  "interactive.yesButton": "\u662F",
  "interactive.noButton": "\u5426",
  "interactive.customPlaceholder": "\u6216\u8F93\u5165\u81EA\u5B9A\u4E49\u56DE\u590D...",
  // Permission Approval
  "permission.header": "\u9700\u8981\u6743\u9650",
  "permission.message": "Claude \u6B63\u5728\u8BF7\u6C42\u6267\u884C\u64CD\u4F5C\u7684\u6743\u9650\u3002",
  "permission.approveButton": "\u6279\u51C6\u5E76\u7EE7\u7EED",
  "permission.denyButton": "\u62D2\u7EDD",
  // Status Messages
  "status.processing": "Claude \u6B63\u5728\u5904\u7406",
  "status.autoApplying": "\u6B63\u5728\u81EA\u52A8\u5E94\u7528\u66F4\u6539...",
  "status.runningAuthorized": "\u6B63\u5728\u6267\u884C\u6388\u6743\u4EFB\u52A1",
  "status.runningInBackground": "\u540E\u53F0\u8FD0\u884C\u4E2D...",
  "status.failed": "\u5931\u8D25 - \u8BF7\u67E5\u770B\u4E0B\u65B9\u9519\u8BEF\u4FE1\u606F",
  // Notifications
  "notice.alreadyProcessing": "\u6B63\u5728\u5904\u7406\u8BF7\u6C42\uFF0C\u8BF7\u7A0D\u5019\u3002",
  "notice.enterPrompt": "\u8BF7\u8F93\u5165\u6307\u4EE4",
  "notice.noActiveNote": "\u672A\u627E\u5230\u6D3B\u52A8\u7B14\u8BB0\uFF0C\u8BF7\u5148\u6253\u5F00\u4E00\u4E2A Markdown \u7B14\u8BB0",
  "notice.noEditor": "\u672A\u627E\u5230 Markdown \u7F16\u8F91\u5668\uFF0C\u8BF7\u786E\u4FDD\u5DF2\u6253\u5F00\u7B14\u8BB0",
  "notice.noVaultPath": "\u65E0\u6CD5\u786E\u5B9A\u4ED3\u5E93\u8DEF\u5F84",
  "notice.completed": "Claude Code \u5DF2\u5B8C\u6210",
  "notice.completedNoChanges": "Claude Code \u5DF2\u5B8C\u6210\uFF08\u65E0\u6587\u4EF6\u66F4\u6539\uFF09",
  "notice.changesApplied": "\u66F4\u6539\u5DF2\u81EA\u52A8\u5E94\u7528",
  "notice.changesAppliedSuccess": "\u66F4\u6539\u5DF2\u6210\u529F\u5E94\u7528",
  "notice.failedApplyChanges": "\u5E94\u7528\u66F4\u6539\u5931\u8D25",
  "notice.changesRejected": "\u66F4\u6539\u5DF2\u62D2\u7EDD",
  "notice.cancelled": "\u5DF2\u53D6\u6D88",
  "notice.permissionRequest": "Claude \u6B63\u5728\u8BF7\u6C42\u6743\u9650 - \u8BF7\u6279\u51C6\u6216\u62D2\u7EDD",
  "notice.permissionDenied": "\u6743\u9650\u88AB\u62D2\u7EDD - Claude \u5C06\u4E0D\u4F1A\u7EE7\u7EED",
  "notice.noChangesToApply": "\u6CA1\u6709\u53EF\u5E94\u7528\u7684\u66F4\u6539",
  "notice.noActiveFile": "\u6CA1\u6709\u6D3B\u52A8\u6587\u4EF6",
  "notice.historyRestored": "\u5386\u53F2\u8BB0\u5F55\u9879\u5DF2\u6062\u590D",
  "notice.historyRestoredWithChanges": "\u5386\u53F2\u8BB0\u5F55\u9879\u5DF2\u6062\u590D\uFF08\u5305\u542B\u5EFA\u8BAE\u7684\u66F4\u6539\uFF09",
  "notice.historyCleared": "\u5386\u53F2\u8BB0\u5F55\u5DF2\u6E05\u9664",
  // Diff View
  "diff.original": "\u539F\u59CB",
  "diff.modified": "\u4FEE\u6539\u540E",
  // Result Renderer
  "result.directAnswer": "\u76F4\u63A5\u56DE\u7B54",
  "result.additionalContext": "\u9644\u52A0\u5185\u5BB9",
  "result.tokens": "\u4EE4\u724C",
  "result.tokensIn": "\u8F93\u5165",
  "result.tokensOut": "\u8F93\u51FA",
  // Preview Stats
  "preview.originalLabel": "\u539F\u59CB\uFF1A",
  "preview.modifiedLabel": "\u4FEE\u6539\u540E\uFF1A",
  "preview.charsLabel": "\u5B57\u7B26",
  // Misc
  "misc.noPendingRequest": "\u672A\u627E\u5230\u5F85\u5904\u7406\u7684\u8BF7\u6C42",
  "misc.languageChanged": "\u8BED\u8A00\u5DF2\u66F4\u6539\u3002\u90E8\u5206\u754C\u9762\u5143\u7D20\u5C06\u5728\u91CD\u65B0\u52A0\u8F7D\u540E\u66F4\u65B0\u3002",
  "misc.testFailed": "Claude Code \u6D4B\u8BD5\u5931\u8D25",
  // Settings
  "settings.autoDetectPath": "\u81EA\u52A8\u68C0\u6D4B Claude Code \u8DEF\u5F84",
  "settings.autoDetectPathDesc": "\u81EA\u52A8\u68C0\u6D4B Claude Code \u53EF\u6267\u884C\u6587\u4EF6\u7684\u4F4D\u7F6E",
  "settings.executablePath": "Claude Code \u53EF\u6267\u884C\u6587\u4EF6\u8DEF\u5F84",
  "settings.executablePathDesc": "Claude Code \u53EF\u6267\u884C\u6587\u4EF6\u7684\u5B8C\u6574\u8DEF\u5F84\uFF08\u4F8B\u5982\uFF1A/usr/local/bin/claude\uFF09",
  "settings.testInstallation": "\u6D4B\u8BD5 Claude Code \u5B89\u88C5",
  "settings.testInstallationDesc": "\u9A8C\u8BC1 Claude Code \u662F\u5426\u53EF\u8BBF\u95EE\u5E76\u6B63\u5E38\u5DE5\u4F5C",
  "settings.testButton": "\u6D4B\u8BD5",
  "settings.testWorking": "\u6B63\u5E38\u5DE5\u4F5C\uFF01",
  "settings.testFailed": "\u5931\u8D25",
  "settings.customPrompt": "\u81EA\u5B9A\u4E49\u7CFB\u7EDF\u63D0\u793A",
  "settings.customPromptDesc": "\u53EF\u9009\u7684\u81EA\u5B9A\u4E49\u7CFB\u7EDF\u63D0\u793A\uFF0C\u5C06\u6DFB\u52A0\u5230\u6240\u6709\u8BF7\u6C42\u524D",
  "settings.customPromptPlaceholder": "\u4F60\u6B63\u5728\u5E2E\u52A9\u7F16\u8F91 Markdown \u7B14\u8BB0...",
  "settings.preserveCursor": "\u4FDD\u6301\u5149\u6807\u4F4D\u7F6E",
  "settings.preserveCursorDesc": "\u5E94\u7528\u66F4\u6539\u540E\u5C1D\u8BD5\u4FDD\u6301\u5149\u6807\u4F4D\u7F6E",
  "settings.autoAcceptChanges": "\u81EA\u52A8\u63A5\u53D7\u66F4\u6539",
  "settings.autoAcceptChangesDesc": "\u81EA\u52A8\u5E94\u7528\u66F4\u6539\u800C\u4E0D\u663E\u793A\u9884\u89C8\uFF08\u8BF7\u8C28\u614E\u4F7F\u7528\uFF01\uFF09",
  "settings.model": "\u6A21\u578B",
  "settings.modelDesc": "\u9009\u62E9\u8981\u4F7F\u7528\u7684 Claude \u6A21\u578B\uFF1ASonnet\uFF08\u5E73\u8861\uFF09\u3001Opus\uFF08\u6700\u5F3A\u5927\uFF09\u6216 Haiku\uFF08\u6700\u5FEB\uFF09\u3002\u7559\u7A7A\u4F7F\u7528\u9ED8\u8BA4\u5B50\u4EE3\u7406\u6A21\u578B\u3002",
  "settings.modelDefault": "\u9ED8\u8BA4\uFF08\u5B50\u4EE3\u7406\u6A21\u578B\uFF09",
  "settings.modelSonnet": "Sonnet\uFF08\u5E73\u8861\uFF09",
  "settings.modelOpus": "Opus\uFF08\u6700\u5F3A\u5927\uFF09",
  "settings.modelHaiku": "Haiku\uFF08\u6700\u5FEB\uFF09",
  "settings.vaultAccess": "\u5141\u8BB8\u4ED3\u5E93\u8303\u56F4\u8BBF\u95EE",
  "settings.vaultAccessDesc": "\u5141\u8BB8 Claude \u8BFB\u53D6/\u641C\u7D22\u4ED3\u5E93\u4E2D\u7684\u5176\u4ED6\u6587\u4EF6\uFF08\u4E0D\u4EC5\u4EC5\u662F\u5F53\u524D\u7B14\u8BB0\uFF09",
  "settings.permissionlessMode": "\u542F\u7528\u65E0\u6743\u9650\u6A21\u5F0F",
  "settings.permissionlessModeDesc": "\u5141\u8BB8 Claude \u6267\u884C\u64CD\u4F5C\u800C\u65E0\u9700\u6BCF\u6B21\u8BF7\u6C42\u6743\u9650\uFF08\u8BF7\u8C28\u614E\u4F7F\u7528\uFF01Claude \u5C06\u62E5\u6709\u5B8C\u5168\u63A7\u5236\u6743\uFF09",
  "settings.timeout": "\u8D85\u65F6\u65F6\u95F4\uFF08\u79D2\uFF09",
  "settings.timeoutDesc": "\u7B49\u5F85 Claude Code \u54CD\u5E94\u7684\u6700\u957F\u65F6\u95F4\uFF080 = \u65E0\u8D85\u65F6\uFF09",
  "settings.customApiConfig": "\u81EA\u5B9A\u4E49 API \u914D\u7F6E",
  "settings.customApiConfigDesc": "\u4E3A Claude \u4E0D\u53EF\u76F4\u63A5\u8BBF\u95EE\u7684\u5730\u533A\u914D\u7F6E\u81EA\u5B9A\u4E49 API \u7AEF\u70B9\u3002\u7559\u7A7A\u4F7F\u7528\u9ED8\u8BA4\u8BBE\u7F6E\u3002",
  "settings.apiBaseUrl": "API \u57FA\u7840 URL",
  "settings.apiBaseUrlDesc": "\u81EA\u5B9A\u4E49 API \u7AEF\u70B9 URL\uFF08\u4F8B\u5982\uFF1Ahttps://api.kimi.com/coding/\uFF09",
  "settings.apiAuthToken": "API \u8BA4\u8BC1\u4EE4\u724C",
  "settings.apiAuthTokenDesc": "API \u7AEF\u70B9\u7684\u81EA\u5B9A\u4E49\u8BA4\u8BC1\u4EE4\u724C",
  "settings.apiAuthTokenPlaceholder": "\u8F93\u5165\u60A8\u7684 API \u4EE4\u724C",
  "settings.customModel": "\u81EA\u5B9A\u4E49\u6A21\u578B",
  "settings.customModelDesc": "\u8981\u4F7F\u7528\u7684\u81EA\u5B9A\u4E49\u6A21\u578B\u540D\u79F0\uFF08\u4F8B\u5982\uFF1Akimi-for-coding\uFF09\u3002\u5C06\u8986\u76D6\u4E0A\u9762\u7684\u6A21\u578B\u4E0B\u62C9\u9009\u9879\u3002",
  "settings.customSmallModel": "\u81EA\u5B9A\u4E49\u5C0F\u578B/\u5FEB\u901F\u6A21\u578B",
  "settings.customSmallModelDesc": "\u7528\u4E8E\u5FEB\u901F\u64CD\u4F5C\u7684\u81EA\u5B9A\u4E49\u6A21\u578B\u540D\u79F0\uFF08\u4F8B\u5982\uFF1Akimi-for-coding\uFF09",
  "settings.language": "\u8BED\u8A00",
  "settings.languageDesc": "\u9009\u62E9\u754C\u9762\u8BED\u8A00"
};

// src/i18n/locales/es.ts
var es = {
  // Header
  "header.title": "Asistente Claude Code",
  "header.noNoteSelected": "ninguna nota seleccionada",
  // Input Section
  "input.label": "Tus instrucciones:",
  "input.placeholder": 'ej., "Agregar m\xE1s ejemplos a esta secci\xF3n" o "Reorganizar con mejores encabezados" (Enter para enviar, Ctrl+Enter para nueva l\xEDnea)',
  "input.conversationalMode": "modo conversacional (sin edici\xF3n de archivos)",
  "input.conversationalModeTooltip": "Chatea con Claude sin modificar ning\xFAn archivo",
  "input.selectedTextOnly": "Editar solo texto seleccionado",
  "input.autoAccept": "Aceptar cambios autom\xE1ticamente",
  "input.modelLabel": "Modelo:",
  "input.modelDefault": "Predeterminado",
  "input.runButton": "Ejecutar Claude Code",
  "input.runningButton": "Ejecutando...",
  "input.cancelButton": "Cancelar",
  // Result Section
  "result.title": "Resultado",
  // Output Section
  "output.title": "Salida",
  // Preview Section
  "preview.title": "Vista previa",
  "preview.tabRaw": "Sin formato",
  "preview.tabDiff": "Diferencias",
  "preview.tabRendered": "Renderizado",
  "preview.originalChars": "Original:",
  "preview.modifiedChars": "Modificado:",
  "preview.chars": "caracteres",
  "preview.applyButton": "aplicar cambios",
  "preview.rejectButton": "rechazar",
  // History Section
  "history.title": "Historial",
  "history.clearButton": "Limpiar",
  // Agent Section
  "agent.planTitle": "plan",
  "agent.activityTitle": "Actividad",
  "agent.noPlan": "A\xFAn no se ha creado un plan",
  // Todo Status
  "todo.pending": "pendiente",
  "todo.inProgress": "en progreso",
  "todo.completed": "completado",
  // Interactive Prompt
  "interactive.header": "Claude est\xE1 solicitando confirmaci\xF3n",
  "interactive.yesButton": "s\xED",
  "interactive.noButton": "no",
  "interactive.customPlaceholder": "O escribe una respuesta personalizada...",
  // Permission Approval
  "permission.header": "permiso requerido",
  "permission.message": "Claude est\xE1 solicitando permiso para ejecutar acciones.",
  "permission.approveButton": "aprobar y continuar",
  "permission.denyButton": "denegar",
  // Status Messages
  "status.processing": "Claude est\xE1 procesando",
  "status.autoApplying": "Aplicando cambios autom\xE1ticamente...",
  "status.runningAuthorized": "Ejecutando tareas autorizadas",
  "status.runningInBackground": "Ejecutando en segundo plano...",
  "status.failed": "Fall\xF3 - ver error abajo",
  // Notifications
  "notice.alreadyProcessing": "Ya se est\xE1 procesando una solicitud. Por favor espera.",
  "notice.enterPrompt": "Por favor ingresa una instrucci\xF3n",
  "notice.noActiveNote": "No se encontr\xF3 una nota activa, por favor abre una nota Markdown primero",
  "notice.noEditor": "No se encontr\xF3 un editor Markdown, aseg\xFArate de tener una nota abierta",
  "notice.noVaultPath": "No se pudo determinar la ruta de la b\xF3veda",
  "notice.completed": "Claude Code completado",
  "notice.completedNoChanges": "Claude Code completado (sin cambios en archivos)",
  "notice.changesApplied": "cambios aplicados autom\xE1ticamente",
  "notice.changesAppliedSuccess": "cambios aplicados exitosamente",
  "notice.failedApplyChanges": "fall\xF3 al aplicar cambios",
  "notice.changesRejected": "Cambios rechazados",
  "notice.cancelled": "Cancelado",
  "notice.permissionRequest": "Claude est\xE1 solicitando permiso - por favor aprueba o deniega",
  "notice.permissionDenied": "Permiso denegado - Claude no proceder\xE1",
  "notice.noChangesToApply": "no hay cambios para aplicar",
  "notice.noActiveFile": "no hay archivo activo",
  "notice.historyRestored": "Elemento del historial restaurado",
  "notice.historyRestoredWithChanges": "Elemento del historial restaurado con cambios propuestos",
  "notice.historyCleared": "Historial limpiado",
  // Diff View
  "diff.original": "Original",
  "diff.modified": "Modificado",
  // Result Renderer
  "result.directAnswer": "Respuesta directa",
  "result.additionalContext": "Contexto adicional",
  "result.tokens": "tokens",
  "result.tokensIn": "entrada",
  "result.tokensOut": "salida",
  // Preview Stats
  "preview.originalLabel": "Original:",
  "preview.modifiedLabel": "Modificado:",
  "preview.charsLabel": "caracteres",
  // Misc
  "misc.noPendingRequest": "No se encontr\xF3 solicitud pendiente",
  "misc.languageChanged": "Idioma cambiado. Algunos elementos de la interfaz se actualizar\xE1n al recargar.",
  "misc.testFailed": "Prueba de Claude Code fallida",
  // Settings
  "settings.autoDetectPath": "Auto-detectar ruta de Claude Code",
  "settings.autoDetectPathDesc": "Detectar autom\xE1ticamente la ubicaci\xF3n del ejecutable de Claude Code",
  "settings.executablePath": "Ruta del ejecutable de Claude Code",
  "settings.executablePathDesc": "Ruta completa al ejecutable de Claude Code (ej., /usr/local/bin/claude)",
  "settings.testInstallation": "Probar instalaci\xF3n de Claude Code",
  "settings.testInstallationDesc": "Verificar que Claude Code sea accesible y funcione",
  "settings.testButton": "Probar",
  "settings.testWorking": "\xA1funcionando!",
  "settings.testFailed": "fall\xF3",
  "settings.customPrompt": "Prompt de sistema personalizado",
  "settings.customPromptDesc": "Prompt de sistema personalizado opcional para agregar a todas las solicitudes",
  "settings.customPromptPlaceholder": "Est\xE1s ayudando a editar notas markdown...",
  "settings.preserveCursor": "Preservar posici\xF3n del cursor",
  "settings.preserveCursorDesc": "Intentar mantener la posici\xF3n del cursor despu\xE9s de aplicar cambios",
  "settings.autoAcceptChanges": "Aceptar cambios autom\xE1ticamente",
  "settings.autoAcceptChangesDesc": "Aplicar cambios autom\xE1ticamente sin mostrar vista previa (\xA1usar con precauci\xF3n!)",
  "settings.model": "Modelo",
  "settings.modelDesc": "Selecciona el modelo de Claude a usar: Sonnet (equilibrado), Opus (m\xE1s capaz), o Haiku (m\xE1s r\xE1pido). Dejar vac\xEDo para usar el modelo de subagente predeterminado.",
  "settings.modelDefault": "Predeterminado (modelo subagente)",
  "settings.modelSonnet": "Sonnet (equilibrado)",
  "settings.modelOpus": "Opus (m\xE1s capaz)",
  "settings.modelHaiku": "Haiku (m\xE1s r\xE1pido)",
  "settings.vaultAccess": "Permitir acceso a toda la b\xF3veda",
  "settings.vaultAccessDesc": "Permitir a Claude leer/buscar otros archivos en tu b\xF3veda (no solo la nota actual)",
  "settings.permissionlessMode": "Habilitar modo sin permisos",
  "settings.permissionlessModeDesc": "Permitir a Claude ejecutar acciones sin pedir permiso cada vez (\xA1usar con precauci\xF3n! Claude tendr\xE1 control total)",
  "settings.timeout": "Tiempo de espera (segundos)",
  "settings.timeoutDesc": "Tiempo m\xE1ximo de espera para la respuesta de Claude Code (0 = sin l\xEDmite)",
  "settings.customApiConfig": "Configuraci\xF3n de API personalizada",
  "settings.customApiConfigDesc": "Configurar endpoints de API personalizados para regiones donde Claude no est\xE1 disponible directamente. Dejar vac\xEDo para usar la configuraci\xF3n predeterminada.",
  "settings.apiBaseUrl": "URL base de API",
  "settings.apiBaseUrlDesc": "URL del endpoint de API personalizado (ej., https://api.kimi.com/coding/)",
  "settings.apiAuthToken": "Token de autenticaci\xF3n de API",
  "settings.apiAuthTokenDesc": "Token de autenticaci\xF3n personalizado para el endpoint de API",
  "settings.apiAuthTokenPlaceholder": "Ingresa tu token de API",
  "settings.customModel": "Modelo personalizado",
  "settings.customModelDesc": "Nombre del modelo personalizado a usar (ej., kimi-for-coding). Sobrescribe el selector de modelo anterior.",
  "settings.customSmallModel": "Modelo peque\xF1o/r\xE1pido personalizado",
  "settings.customSmallModelDesc": "Nombre del modelo personalizado para operaciones r\xE1pidas (ej., kimi-for-coding)",
  "settings.language": "Idioma",
  "settings.languageDesc": "Seleccionar idioma de la interfaz"
};

// src/i18n/locales/de.ts
var de = {
  // Header
  "header.title": "Claude Code Assistent",
  "header.noNoteSelected": "keine Notiz ausgew\xE4hlt",
  // Input Section
  "input.label": "Deine Anweisungen:",
  "input.placeholder": 'z.B. "F\xFCge mehr Beispiele zu diesem Abschnitt hinzu" oder "Reorganisiere mit besseren \xDCberschriften" (Enter zum Senden, Strg+Enter f\xFCr neue Zeile)',
  "input.conversationalMode": "Konversationsmodus (keine Datei\xE4nderungen)",
  "input.conversationalModeTooltip": "Mit Claude chatten, ohne Dateien zu \xE4ndern",
  "input.selectedTextOnly": "Nur markierten Text bearbeiten",
  "input.autoAccept": "\xC4nderungen automatisch \xFCbernehmen",
  "input.modelLabel": "Modell:",
  "input.modelDefault": "Standard",
  "input.runButton": "Claude Code ausf\xFChren",
  "input.runningButton": "L\xE4uft...",
  "input.cancelButton": "Abbrechen",
  // Result Section
  "result.title": "Ergebnis",
  // Output Section
  "output.title": "Ausgabe",
  // Preview Section
  "preview.title": "Vorschau",
  "preview.tabRaw": "Roh",
  "preview.tabDiff": "Diff",
  "preview.tabRendered": "Gerendert",
  "preview.originalChars": "Original:",
  "preview.modifiedChars": "Ge\xE4ndert:",
  "preview.chars": "Zeichen",
  "preview.applyButton": "\xC4nderungen \xFCbernehmen",
  "preview.rejectButton": "Ablehnen",
  // History Section
  "history.title": "Verlauf",
  "history.clearButton": "L\xF6schen",
  // Agent Section
  "agent.planTitle": "Plan",
  "agent.activityTitle": "Aktivit\xE4t",
  "agent.noPlan": "Noch kein Plan erstellt",
  // Todo Status
  "todo.pending": "Ausstehend",
  "todo.inProgress": "In Bearbeitung",
  "todo.completed": "Abgeschlossen",
  // Interactive Prompt
  "interactive.header": "Claude bittet um Best\xE4tigung",
  "interactive.yesButton": "Ja",
  "interactive.noButton": "Nein",
  "interactive.customPlaceholder": "Oder eine eigene Antwort eingeben...",
  // Permission Approval
  "permission.header": "Berechtigung erforderlich",
  "permission.message": "Claude bittet um Erlaubnis, Aktionen auszuf\xFChren.",
  "permission.approveButton": "Genehmigen & fortfahren",
  "permission.denyButton": "Ablehnen",
  // Status Messages
  "status.processing": "Claude verarbeitet",
  "status.autoApplying": "\xC4nderungen werden automatisch \xFCbernommen...",
  "status.runningAuthorized": "F\xFChre autorisierte Aufgaben aus",
  "status.runningInBackground": "L\xE4uft im Hintergrund...",
  "status.failed": "Fehlgeschlagen - siehe Fehler unten",
  // Notifications
  "notice.alreadyProcessing": "Eine Anfrage wird bereits verarbeitet. Bitte warten.",
  "notice.enterPrompt": "Bitte gib eine Anweisung ein",
  "notice.noActiveNote": "Keine aktive Notiz gefunden, bitte \xF6ffne zuerst eine Markdown-Notiz",
  "notice.noEditor": "Kein Markdown-Editor gefunden, bitte stelle sicher, dass eine Notiz ge\xF6ffnet ist",
  "notice.noVaultPath": "Vault-Pfad konnte nicht ermittelt werden",
  "notice.completed": "Claude Code abgeschlossen",
  "notice.completedNoChanges": "Claude Code abgeschlossen (keine Datei\xE4nderungen)",
  "notice.changesApplied": "\xC4nderungen automatisch \xFCbernommen",
  "notice.changesAppliedSuccess": "\xC4nderungen erfolgreich \xFCbernommen",
  "notice.failedApplyChanges": "\xC4nderungen konnten nicht \xFCbernommen werden",
  "notice.changesRejected": "\xC4nderungen abgelehnt",
  "notice.cancelled": "Abgebrochen",
  "notice.permissionRequest": "Claude bittet um Berechtigung - bitte genehmigen oder ablehnen",
  "notice.permissionDenied": "Berechtigung verweigert - Claude wird nicht fortfahren",
  "notice.noChangesToApply": "Keine \xC4nderungen zum \xDCbernehmen",
  "notice.noActiveFile": "Keine aktive Datei",
  "notice.historyRestored": "Verlaufseintrag wiederhergestellt",
  "notice.historyRestoredWithChanges": "Verlaufseintrag mit vorgeschlagenen \xC4nderungen wiederhergestellt",
  "notice.historyCleared": "Verlauf gel\xF6scht",
  // Diff View
  "diff.original": "Original",
  "diff.modified": "Ge\xE4ndert",
  // Result Renderer
  "result.directAnswer": "Direkte Antwort",
  "result.additionalContext": "Zus\xE4tzlicher Kontext",
  "result.tokens": "Tokens",
  "result.tokensIn": "Eingabe",
  "result.tokensOut": "Ausgabe",
  // Preview Stats
  "preview.originalLabel": "Original:",
  "preview.modifiedLabel": "Ge\xE4ndert:",
  "preview.charsLabel": "Zeichen",
  // Misc
  "misc.noPendingRequest": "Keine ausstehende Anfrage gefunden",
  "misc.languageChanged": "Sprache ge\xE4ndert. Einige UI-Elemente werden nach dem Neuladen aktualisiert.",
  "misc.testFailed": "Claude Code Test fehlgeschlagen",
  // Settings
  "settings.autoDetectPath": "Claude Code Pfad automatisch erkennen",
  "settings.autoDetectPathDesc": "Den Speicherort der Claude Code Anwendung automatisch erkennen",
  "settings.executablePath": "Claude Code Anwendungspfad",
  "settings.executablePathDesc": "Vollst\xE4ndiger Pfad zur Claude Code Anwendung (z.B. /usr/local/bin/claude)",
  "settings.testInstallation": "Claude Code Installation testen",
  "settings.testInstallationDesc": "\xDCberpr\xFCfen, ob Claude Code erreichbar ist und funktioniert",
  "settings.testButton": "Testen",
  "settings.testWorking": "Funktioniert!",
  "settings.testFailed": "Fehlgeschlagen",
  "settings.customPrompt": "Benutzerdefinierte Systemanweisung",
  "settings.customPromptDesc": "Optionale benutzerdefinierte Systemanweisung, die allen Anfragen vorangestellt wird",
  "settings.customPromptPlaceholder": "Du hilfst beim Bearbeiten von Markdown-Notizen...",
  "settings.preserveCursor": "Cursorposition beibehalten",
  "settings.preserveCursorDesc": "Versuchen, die Cursorposition nach dem \xDCbernehmen von \xC4nderungen beizubehalten",
  "settings.autoAcceptChanges": "\xC4nderungen automatisch \xFCbernehmen",
  "settings.autoAcceptChangesDesc": "\xC4nderungen automatisch \xFCbernehmen, ohne Vorschau anzuzeigen (mit Vorsicht verwenden!)",
  "settings.model": "Modell",
  "settings.modelDesc": "W\xE4hle das Claude-Modell: Sonnet (ausgewogen), Opus (leistungsf\xE4higste), oder Haiku (schnellste). Leer lassen f\xFCr Standard-Subagent-Modell.",
  "settings.modelDefault": "Standard (Subagent-Modell)",
  "settings.modelSonnet": "Sonnet (ausgewogen)",
  "settings.modelOpus": "Opus (leistungsf\xE4higste)",
  "settings.modelHaiku": "Haiku (schnellste)",
  "settings.vaultAccess": "Vault-weiten Zugriff erlauben",
  "settings.vaultAccessDesc": "Claude erlauben, andere Dateien im Vault zu lesen/durchsuchen (nicht nur die aktuelle Notiz)",
  "settings.permissionlessMode": "Berechtigungsfreien Modus aktivieren",
  "settings.permissionlessModeDesc": "Claude erlauben, Aktionen auszuf\xFChren, ohne jedes Mal um Erlaubnis zu fragen (mit Vorsicht verwenden! Claude hat volle Kontrolle)",
  "settings.timeout": "Zeitlimit (Sekunden)",
  "settings.timeoutDesc": "Maximale Wartezeit auf Claude Code Antwort (0 = kein Zeitlimit)",
  "settings.customApiConfig": "Benutzerdefinierte API-Konfiguration",
  "settings.customApiConfigDesc": "Benutzerdefinierte API-Endpunkte f\xFCr Regionen konfigurieren, in denen Claude nicht direkt verf\xFCgbar ist. Leer lassen f\xFCr Standardeinstellungen.",
  "settings.apiBaseUrl": "API Basis-URL",
  "settings.apiBaseUrlDesc": "Benutzerdefinierte API-Endpunkt-URL (z.B. https://api.kimi.com/coding/)",
  "settings.apiAuthToken": "API Auth-Token",
  "settings.apiAuthTokenDesc": "Benutzerdefiniertes Authentifizierungstoken f\xFCr den API-Endpunkt",
  "settings.apiAuthTokenPlaceholder": "Gib dein API-Token ein",
  "settings.customModel": "Benutzerdefiniertes Modell",
  "settings.customModelDesc": "Benutzerdefinierter Modellname (z.B. kimi-for-coding). \xDCberschreibt die Modellauswahl oben.",
  "settings.customSmallModel": "Benutzerdefiniertes kleines/schnelles Modell",
  "settings.customSmallModelDesc": "Benutzerdefinierter Modellname f\xFCr schnelle Operationen (z.B. kimi-for-coding)",
  "settings.language": "Sprache",
  "settings.languageDesc": "Oberfl\xE4chensprache ausw\xE4hlen"
};

// src/i18n/locales/pt.ts
var pt = {
  // Header
  "header.title": "Assistente Claude Code",
  "header.noNoteSelected": "nenhuma nota selecionada",
  // Input Section
  "input.label": "Suas instru\xE7\xF5es:",
  "input.placeholder": 'ex., "Adicione mais exemplos a esta se\xE7\xE3o" ou "Reorganize com melhores t\xEDtulos" (Enter para enviar, Ctrl+Enter para nova linha)',
  "input.conversationalMode": "modo conversacional (sem edi\xE7\xE3o de arquivos)",
  "input.conversationalModeTooltip": "Converse com Claude sem modificar arquivos",
  "input.selectedTextOnly": "Editar apenas texto selecionado",
  "input.autoAccept": "Aceitar altera\xE7\xF5es automaticamente",
  "input.modelLabel": "Modelo:",
  "input.modelDefault": "Padr\xE3o",
  "input.runButton": "Executar Claude Code",
  "input.runningButton": "Executando...",
  "input.cancelButton": "Cancelar",
  // Result Section
  "result.title": "Resultado",
  // Output Section
  "output.title": "Sa\xEDda",
  // Preview Section
  "preview.title": "Visualiza\xE7\xE3o",
  "preview.tabRaw": "Bruto",
  "preview.tabDiff": "Diferen\xE7as",
  "preview.tabRendered": "Renderizado",
  "preview.originalChars": "Original:",
  "preview.modifiedChars": "Modificado:",
  "preview.chars": "caracteres",
  "preview.applyButton": "aplicar altera\xE7\xF5es",
  "preview.rejectButton": "rejeitar",
  // History Section
  "history.title": "Hist\xF3rico",
  "history.clearButton": "Limpar",
  // Agent Section
  "agent.planTitle": "plano",
  "agent.activityTitle": "Atividade",
  "agent.noPlan": "Nenhum plano criado ainda",
  // Todo Status
  "todo.pending": "pendente",
  "todo.inProgress": "em progresso",
  "todo.completed": "conclu\xEDdo",
  // Interactive Prompt
  "interactive.header": "Claude est\xE1 pedindo confirma\xE7\xE3o",
  "interactive.yesButton": "sim",
  "interactive.noButton": "n\xE3o",
  "interactive.customPlaceholder": "Ou digite uma resposta personalizada...",
  // Permission Approval
  "permission.header": "permiss\xE3o necess\xE1ria",
  "permission.message": "Claude est\xE1 solicitando permiss\xE3o para executar a\xE7\xF5es.",
  "permission.approveButton": "aprovar e continuar",
  "permission.denyButton": "negar",
  // Status Messages
  "status.processing": "Claude est\xE1 processando",
  "status.autoApplying": "Aplicando altera\xE7\xF5es automaticamente...",
  "status.runningAuthorized": "Executando tarefas autorizadas",
  "status.runningInBackground": "Executando em segundo plano...",
  "status.failed": "Falhou - veja o erro abaixo",
  // Notifications
  "notice.alreadyProcessing": "J\xE1 est\xE1 processando uma solicita\xE7\xE3o. Por favor, aguarde.",
  "notice.enterPrompt": "Por favor, insira um prompt",
  "notice.noActiveNote": "Nenhuma nota ativa encontrada, por favor abra uma nota Markdown primeiro",
  "notice.noEditor": "Nenhum editor Markdown encontrado, certifique-se de que voc\xEA tem uma nota aberta",
  "notice.noVaultPath": "N\xE3o foi poss\xEDvel determinar o caminho do vault",
  "notice.completed": "Claude Code conclu\xEDdo",
  "notice.completedNoChanges": "Claude Code conclu\xEDdo (sem altera\xE7\xF5es de arquivo)",
  "notice.changesApplied": "altera\xE7\xF5es aplicadas automaticamente",
  "notice.changesAppliedSuccess": "altera\xE7\xF5es aplicadas com sucesso",
  "notice.failedApplyChanges": "falha ao aplicar altera\xE7\xF5es",
  "notice.changesRejected": "Altera\xE7\xF5es rejeitadas",
  "notice.cancelled": "Cancelado",
  "notice.permissionRequest": "Claude est\xE1 solicitando permiss\xE3o - por favor aprove ou negue",
  "notice.permissionDenied": "Permiss\xE3o negada - Claude n\xE3o prosseguir\xE1",
  "notice.noChangesToApply": "nenhuma altera\xE7\xE3o para aplicar",
  "notice.noActiveFile": "nenhum arquivo ativo",
  "notice.historyRestored": "Item do hist\xF3rico restaurado",
  "notice.historyRestoredWithChanges": "Item do hist\xF3rico restaurado com altera\xE7\xF5es propostas",
  "notice.historyCleared": "Hist\xF3rico limpo",
  // Diff View
  "diff.original": "Original",
  "diff.modified": "Modificado",
  // Result Renderer
  "result.directAnswer": "Resposta direta",
  "result.additionalContext": "Contexto adicional",
  "result.tokens": "tokens",
  "result.tokensIn": "entrada",
  "result.tokensOut": "sa\xEDda",
  // Preview Stats
  "preview.originalLabel": "Original:",
  "preview.modifiedLabel": "Modificado:",
  "preview.charsLabel": "caracteres",
  // Misc
  "misc.noPendingRequest": "Nenhuma solicita\xE7\xE3o pendente encontrada",
  "misc.languageChanged": "Idioma alterado. Alguns elementos da interface ser\xE3o atualizados ao recarregar.",
  "misc.testFailed": "Teste do Claude Code falhou",
  // Settings
  "settings.autoDetectPath": "Detectar caminho do Claude Code automaticamente",
  "settings.autoDetectPathDesc": "Detectar automaticamente a localiza\xE7\xE3o do execut\xE1vel do Claude Code",
  "settings.executablePath": "Caminho do execut\xE1vel do Claude Code",
  "settings.executablePathDesc": "Caminho completo para o execut\xE1vel do Claude Code (ex., /usr/local/bin/claude)",
  "settings.testInstallation": "Testar instala\xE7\xE3o do Claude Code",
  "settings.testInstallationDesc": "Verificar se o Claude Code est\xE1 acess\xEDvel e funcionando",
  "settings.testButton": "Testar",
  "settings.testWorking": "funcionando!",
  "settings.testFailed": "falhou",
  "settings.customPrompt": "Prompt de sistema personalizado",
  "settings.customPromptDesc": "Prompt de sistema personalizado opcional para adicionar a todas as solicita\xE7\xF5es",
  "settings.customPromptPlaceholder": "Voc\xEA est\xE1 ajudando a editar notas markdown...",
  "settings.preserveCursor": "Preservar posi\xE7\xE3o do cursor",
  "settings.preserveCursorDesc": "Tentar manter a posi\xE7\xE3o do cursor ap\xF3s aplicar altera\xE7\xF5es",
  "settings.autoAcceptChanges": "Aceitar altera\xE7\xF5es automaticamente",
  "settings.autoAcceptChangesDesc": "Aplicar altera\xE7\xF5es automaticamente sem mostrar visualiza\xE7\xE3o (use com cautela!)",
  "settings.model": "Modelo",
  "settings.modelDesc": "Selecione o modelo Claude a usar: Sonnet (equilibrado), Opus (mais capaz), ou Haiku (mais r\xE1pido). Deixe vazio para usar o modelo subagent padr\xE3o.",
  "settings.modelDefault": "Padr\xE3o (modelo subagent)",
  "settings.modelSonnet": "Sonnet (equilibrado)",
  "settings.modelOpus": "Opus (mais capaz)",
  "settings.modelHaiku": "Haiku (mais r\xE1pido)",
  "settings.vaultAccess": "Permitir acesso ao vault completo",
  "settings.vaultAccessDesc": "Permitir que Claude leia/pesquise outros arquivos no seu vault (n\xE3o apenas a nota atual)",
  "settings.permissionlessMode": "Habilitar modo sem permiss\xF5es",
  "settings.permissionlessModeDesc": "Permitir que Claude execute a\xE7\xF5es sem pedir permiss\xE3o a cada vez (use com cautela! Claude ter\xE1 controle total)",
  "settings.timeout": "Tempo limite (segundos)",
  "settings.timeoutDesc": "Tempo m\xE1ximo para aguardar resposta do Claude Code (0 = sem limite)",
  "settings.customApiConfig": "Configura\xE7\xE3o de API personalizada",
  "settings.customApiConfigDesc": "Configure endpoints de API personalizados para regi\xF5es onde Claude n\xE3o est\xE1 dispon\xEDvel diretamente. Deixe vazio para usar configura\xE7\xF5es padr\xE3o.",
  "settings.apiBaseUrl": "URL base da API",
  "settings.apiBaseUrlDesc": "URL do endpoint de API personalizado (ex., https://api.kimi.com/coding/)",
  "settings.apiAuthToken": "Token de autentica\xE7\xE3o da API",
  "settings.apiAuthTokenDesc": "Token de autentica\xE7\xE3o personalizado para o endpoint da API",
  "settings.apiAuthTokenPlaceholder": "Insira seu token de API",
  "settings.customModel": "Modelo personalizado",
  "settings.customModelDesc": "Nome do modelo personalizado a usar (ex., kimi-for-coding). Substitui a sele\xE7\xE3o de modelo acima.",
  "settings.customSmallModel": "Modelo pequeno/r\xE1pido personalizado",
  "settings.customSmallModelDesc": "Nome do modelo personalizado para opera\xE7\xF5es r\xE1pidas (ex., kimi-for-coding)",
  "settings.language": "Idioma",
  "settings.languageDesc": "Selecione o idioma da interface"
};

// src/i18n/index.ts
var translations = {
  en,
  zh,
  es,
  de,
  pt
};
var currentLocale = "en";
function setLocale(locale) {
  if (translations[locale]) {
    currentLocale = locale;
  } else {
    console.warn(`[i18n] Unknown locale: ${locale}, falling back to 'en'`);
    currentLocale = "en";
  }
}
function getLocale() {
  return currentLocale;
}
function getAvailableLocales() {
  return [
    { code: "en", name: "English" },
    { code: "zh", name: "\u4E2D\u6587 (\u7B80\u4F53)" },
    { code: "es", name: "Espa\xF1ol" },
    { code: "de", name: "Deutsch" },
    { code: "pt", name: "Portugu\xEAs" }
  ];
}
function t(key, params) {
  var _a;
  let text = ((_a = translations[currentLocale]) == null ? void 0 : _a[key]) || translations["en"][key] || key;
  if (params) {
    Object.entries(params).forEach(([paramKey, value]) => {
      text = text.replace(new RegExp(`\\{${paramKey}\\}`, "g"), String(value));
    });
  }
  return text;
}
function initI18n(preferredLocale) {
  var _a;
  if (preferredLocale && translations[preferredLocale]) {
    setLocale(preferredLocale);
    return;
  }
  const systemLocale = ((_a = navigator.language) == null ? void 0 : _a.toLowerCase()) || "";
  if (systemLocale.startsWith("zh")) {
    setLocale("zh");
  } else if (systemLocale.startsWith("es")) {
    setLocale("es");
  } else if (systemLocale.startsWith("de")) {
    setLocale("de");
  } else if (systemLocale.startsWith("pt")) {
    setLocale("pt");
  } else {
    setLocale("en");
  }
}

// src/ui/ui-builder.ts
var UIBuilder = class {
  /**
   * Build the header section
   */
  static buildHeader(container) {
    const header = container.createEl("div", { cls: "claude-code-header" });
    const headerTitle = header.createEl("div", { cls: "claude-code-header-title" });
    headerTitle.createEl("h4", { text: t("header.title") });
    const currentNoteLabel = header.createEl("div", { cls: "claude-code-current-note" });
    return currentNoteLabel;
  }
  /**
   * Build the input section with prompt textarea and options
   */
  static buildInputSection(container, autoAcceptDefault, onRun, onCancel) {
    const inputSection = container.createEl("div", { cls: "claude-code-input-section" });
    inputSection.createEl("label", { text: t("input.label") });
    const promptInput = inputSection.createEl("textarea", {
      cls: "claude-code-prompt-input",
      attr: {
        placeholder: t("input.placeholder")
      }
    });
    promptInput.rows = 4;
    const optionsDiv = inputSection.createEl("div", { cls: "claude-code-options" });
    const conversationalLabel = optionsDiv.createEl("label", { cls: "claude-code-checkbox-label" });
    const conversationalModeCheckbox = conversationalLabel.createEl("input", { type: "checkbox" });
    conversationalLabel.appendText(" " + t("input.conversationalMode"));
    conversationalLabel.title = t("input.conversationalModeTooltip");
    const selectedTextLabel = optionsDiv.createEl("label", { cls: "claude-code-checkbox-label" });
    const selectedTextOnlyCheckbox = selectedTextLabel.createEl("input", { type: "checkbox" });
    selectedTextLabel.appendText(" " + t("input.selectedTextOnly"));
    const autoAcceptLabel = optionsDiv.createEl("label", { cls: "claude-code-checkbox-label" });
    const autoAcceptCheckbox = autoAcceptLabel.createEl("input", { type: "checkbox" });
    autoAcceptCheckbox.checked = autoAcceptDefault;
    autoAcceptLabel.appendText(" " + t("input.autoAccept"));
    const modelSelectContainer = optionsDiv.createEl("div", { cls: "claude-code-model-select" });
    modelSelectContainer.createEl("label", { text: t("input.modelLabel") + " ", cls: "claude-code-model-label" });
    const modelSelect = modelSelectContainer.createEl("select", { cls: "claude-code-model-dropdown" });
    modelSelect.createEl("option", { value: "", text: t("input.modelDefault") });
    modelSelect.createEl("option", { value: "sonnet", text: "Sonnet" });
    modelSelect.createEl("option", { value: "opus", text: "Opus" });
    modelSelect.createEl("option", { value: "haiku", text: "Haiku" });
    const buttonContainer = inputSection.createEl("div", { cls: "claude-code-button-container" });
    const runButton = buttonContainer.createEl("button", {
      cls: "mod-cta",
      text: t("input.runButton")
    });
    runButton.addEventListener("click", onRun);
    const cancelButton = buttonContainer.createEl("button", {
      text: t("input.cancelButton"),
      cls: "claude-code-cancel-button claude-code-hidden"
    });
    cancelButton.addEventListener("click", onCancel);
    return {
      promptInput,
      selectedTextOnlyCheckbox,
      autoAcceptCheckbox,
      conversationalModeCheckbox,
      modelSelect,
      runButton,
      cancelButton
    };
  }
  /**
   * Build the combined agent section (plan + activity in two columns)
   */
  static buildAgentSection(container) {
    const agentContainer = container.createEl("div", {
      cls: "claude-code-agent-container claude-code-hidden"
    });
    agentContainer.id = "claude-code-agent-container";
    const planColumn = agentContainer.createEl("div", { cls: "claude-code-agent-column claude-code-plan-column claude-code-hidden" });
    const planHeader = planColumn.createEl("div", { cls: "claude-code-agent-column-header" });
    planHeader.createEl("span", { text: "\u{1F4CB} " + t("agent.planTitle") });
    planColumn.createEl("div", {
      cls: "claude-code-todo-list claude-code-hidden",
      attr: { id: "claude-code-todo-list" }
    });
    const emptyPlanMessage = planColumn.createEl("div", {
      cls: "claude-code-empty-message claude-code-hidden",
      text: t("agent.noPlan")
    });
    emptyPlanMessage.id = "claude-code-empty-plan";
    const activityColumn = agentContainer.createEl("div", { cls: "claude-code-agent-column claude-code-activity-column claude-code-hidden" });
    const activityHeader = activityColumn.createEl("div", { cls: "claude-code-agent-column-header collapsible-header" });
    const activityTitle = activityHeader.createEl("span", { cls: "collapsible-title" });
    activityTitle.createEl("span", { cls: "collapse-indicator", text: "\u25BC " });
    activityTitle.appendText(t("agent.activityTitle"));
    const activitySteps = activityColumn.createEl("div", {
      cls: "claude-code-agent-steps collapsible-content",
      attr: { id: "claude-code-agent-steps" }
    });
    activityHeader.addEventListener("click", () => {
      const isCollapsed = activitySteps.hasClass("claude-code-hidden");
      activitySteps.toggleClass("claude-code-hidden", !isCollapsed);
      const indicator = activityHeader.querySelector(".collapse-indicator");
      if (indicator) {
        indicator.textContent = isCollapsed ? "\u25BC " : "\u25B6 ";
      }
      agentContainer.toggleClass("collapsed", !isCollapsed);
    });
  }
  /**
   * Build the interactive prompt section (for future use)
   */
  static buildInteractivePromptSection(container, onRespond) {
    const interactivePromptSection = container.createEl("div", {
      cls: "claude-code-interactive-prompt claude-code-hidden"
    });
    interactivePromptSection.id = "claude-code-interactive-prompt";
    interactivePromptSection.createEl("div", {
      cls: "interactive-prompt-header",
      text: "\u2753 " + t("interactive.header")
    });
    interactivePromptSection.createEl("div", {
      cls: "interactive-prompt-question",
      attr: { id: "interactive-prompt-question" }
    });
    const promptButtons = interactivePromptSection.createEl("div", {
      cls: "interactive-prompt-buttons"
    });
    const yesButton = promptButtons.createEl("button", {
      cls: "mod-cta",
      text: "\u2713 " + t("interactive.yesButton")
    });
    yesButton.addEventListener("click", () => onRespond("yes"));
    const noButton = promptButtons.createEl("button", {
      text: "\u2717 " + t("interactive.noButton")
    });
    noButton.addEventListener("click", () => onRespond("no"));
    const customResponseInput = interactivePromptSection.createEl("input", {
      cls: "interactive-prompt-input",
      attr: {
        placeholder: t("interactive.customPlaceholder"),
        id: "interactive-prompt-input"
      }
    });
    customResponseInput.addEventListener("keydown", (e) => {
      if (e.key === "Enter") {
        onRespond(customResponseInput.value);
      }
    });
    return interactivePromptSection;
  }
  /**
   * Build the permission approval section
   */
  static buildPermissionApprovalSection(container, onApprove, onDeny) {
    const permissionApprovalSection = container.createEl("div", {
      cls: "claude-code-permission-approval claude-code-hidden"
    });
    permissionApprovalSection.id = "claude-code-permission-approval";
    permissionApprovalSection.createEl("div", {
      cls: "permission-approval-header",
      text: "\u{1F510} " + t("permission.header")
    });
    permissionApprovalSection.createEl("div", {
      cls: "permission-approval-message",
      text: t("permission.message")
    });
    const approvalButtons = permissionApprovalSection.createEl("div", {
      cls: "permission-approval-buttons"
    });
    const approvePermissionButton = approvalButtons.createEl("button", {
      cls: "mod-cta",
      text: "\u2713 " + t("permission.approveButton")
    });
    approvePermissionButton.addEventListener("click", onApprove);
    const denyPermissionButton = approvalButtons.createEl("button", {
      cls: "mod-warning",
      text: "\u2717 " + t("permission.denyButton")
    });
    denyPermissionButton.addEventListener("click", onDeny);
    return { permissionApprovalSection, approvePermissionButton, denyPermissionButton };
  }
  /**
   * Build the result section (for non-edit responses)
   */
  static buildResultSection(container) {
    const resultSection = container.createEl("div", { cls: "claude-code-result-section claude-code-hidden" });
    resultSection.id = "claude-code-result-section";
    const resultHeader = resultSection.createEl("div", { cls: "claude-code-result-header collapsible-header" });
    const headerTitle = resultHeader.createEl("span", { cls: "collapsible-title" });
    headerTitle.createEl("span", { cls: "collapse-indicator", text: "\u25BC " });
    headerTitle.appendText(t("result.title"));
    const contentWrapper = resultSection.createEl("div", { cls: "collapsible-content" });
    const lastPromptArea = contentWrapper.createEl("div", { cls: "claude-code-last-prompt claude-code-hidden" });
    lastPromptArea.id = "claude-code-last-prompt";
    const statusArea = contentWrapper.createEl("div", { cls: "claude-code-status-area claude-code-hidden" });
    const statusTextContainer = statusArea.createEl("div", { cls: "claude-code-status-text" });
    statusTextContainer.createEl("div", { cls: "claude-code-status-spinner" });
    const statusText = statusTextContainer.createEl("span");
    const progressBarContainer = statusArea.createEl("div", { cls: "claude-code-progress-bar-container" });
    progressBarContainer.createEl("div", { cls: "claude-code-progress-bar" });
    const resultArea = contentWrapper.createEl("div", {
      cls: "claude-code-result-area markdown-rendered claude-code-hidden"
    });
    resultHeader.addEventListener("click", () => {
      const isCollapsed = contentWrapper.hasClass("claude-code-hidden");
      contentWrapper.toggleClass("claude-code-hidden", !isCollapsed);
      const indicator = resultHeader.querySelector(".collapse-indicator");
      if (indicator) {
        indicator.textContent = isCollapsed ? "\u25BC " : "\u25B6 ";
      }
      resultSection.toggleClass("collapsed", !isCollapsed);
    });
    return { resultArea, statusArea, statusText, lastPromptArea };
  }
  /**
   * Build the output section
   */
  static buildOutputSection(container) {
    const outputSection = container.createEl("div", { cls: "claude-code-output-section claude-code-hidden" });
    const outputHeader = outputSection.createEl("div", { cls: "claude-code-output-header collapsible-header" });
    const headerTitle = outputHeader.createEl("span", { cls: "collapsible-title" });
    headerTitle.createEl("span", { cls: "collapse-indicator", text: "\u25B6 " });
    headerTitle.appendText(t("output.title"));
    const outputArea = outputSection.createEl("div", {
      cls: "claude-code-output-area collapsible-content claude-code-hidden"
    });
    outputSection.addClass("collapsed");
    outputHeader.addEventListener("click", () => {
      const isCollapsed = outputArea.hasClass("claude-code-hidden");
      outputArea.toggleClass("claude-code-hidden", !isCollapsed);
      const indicator = outputHeader.querySelector(".collapse-indicator");
      if (indicator) {
        indicator.textContent = isCollapsed ? "\u25BC " : "\u25B6 ";
      }
      outputSection.toggleClass("collapsed", !isCollapsed);
    });
    return { outputArea, outputSection };
  }
  /**
   * Build the preview section
   */
  static buildPreviewSection(container, onApply, onReject) {
    const previewSection = container.createEl("div", { cls: "claude-code-preview-section claude-code-hidden" });
    previewSection.id = "claude-code-preview-section";
    const previewHeader = previewSection.createEl("div", { cls: "claude-code-preview-header collapsible-header" });
    const headerTitle = previewHeader.createEl("span", { cls: "collapsible-title" });
    headerTitle.createEl("span", { cls: "collapse-indicator", text: "\u25BC " });
    headerTitle.appendText(t("preview.title"));
    const previewContent = previewSection.createEl("div", { cls: "claude-code-preview-content-wrapper collapsible-content" });
    const previewTabsContainer = previewContent.createEl("div", { cls: "claude-code-preview-tabs" });
    const rawTab = previewTabsContainer.createEl("div", { cls: "preview-tab", text: t("preview.tabRaw") });
    const diffTab = previewTabsContainer.createEl("div", { cls: "preview-tab active", text: t("preview.tabDiff") });
    const renderedTab = previewTabsContainer.createEl("div", { cls: "preview-tab", text: t("preview.tabRendered") });
    const previewContentContainer = previewContent.createEl("div", { cls: "claude-code-preview-content-container" });
    const previewArea = previewContentContainer.createEl("div", { cls: "claude-code-preview-area" });
    const previewButtons = previewContent.createEl("div", { cls: "claude-code-preview-buttons" });
    const applyButton = previewButtons.createEl("button", {
      cls: "mod-cta",
      text: "\u2713 " + t("preview.applyButton")
    });
    applyButton.addEventListener("click", onApply);
    const rejectButton = previewButtons.createEl("button", {
      cls: "mod-warning",
      text: "\u2717 " + t("preview.rejectButton")
    });
    rejectButton.addEventListener("click", onReject);
    rawTab.addEventListener("click", () => {
      rawTab.addClass("active");
      diffTab.removeClass("active");
      renderedTab.removeClass("active");
      previewArea.removeClass("claude-code-hidden");
      const diffArea = previewContentContainer.querySelector(".claude-code-preview-diff");
      const renderedArea = previewContentContainer.querySelector(".claude-code-preview-rendered");
      if (diffArea)
        diffArea.addClass("claude-code-hidden");
      if (renderedArea)
        renderedArea.addClass("claude-code-hidden");
    });
    diffTab.addEventListener("click", () => {
      diffTab.addClass("active");
      rawTab.removeClass("active");
      renderedTab.removeClass("active");
      previewArea.addClass("claude-code-hidden");
      const diffArea = previewContentContainer.querySelector(".claude-code-preview-diff");
      const renderedArea = previewContentContainer.querySelector(".claude-code-preview-rendered");
      if (diffArea)
        diffArea.removeClass("claude-code-hidden");
      if (renderedArea)
        renderedArea.addClass("claude-code-hidden");
    });
    renderedTab.addEventListener("click", () => {
      renderedTab.addClass("active");
      rawTab.removeClass("active");
      diffTab.removeClass("active");
      previewArea.addClass("claude-code-hidden");
      const diffArea = previewContentContainer.querySelector(".claude-code-preview-diff");
      const renderedArea = previewContentContainer.querySelector(".claude-code-preview-rendered");
      if (diffArea)
        diffArea.addClass("claude-code-hidden");
      if (renderedArea)
        renderedArea.removeClass("claude-code-hidden");
    });
    headerTitle.addEventListener("click", () => {
      const isCollapsed = previewContent.hasClass("claude-code-hidden");
      previewContent.toggleClass("claude-code-hidden", !isCollapsed);
      const indicator = previewHeader.querySelector(".collapse-indicator");
      if (indicator) {
        indicator.textContent = isCollapsed ? "\u25BC " : "\u25B6 ";
      }
      previewSection.toggleClass("collapsed", !isCollapsed);
    });
    return { previewArea, previewContentContainer, previewTabsContainer, applyButton, rejectButton };
  }
  /**
   * Build the history section
   */
  static buildHistorySection(container, onClearHistory) {
    const historySection = container.createEl("div", { cls: "claude-code-history-section claude-code-hidden" });
    historySection.id = "claude-code-history-section";
    const historyHeader = historySection.createEl("div", { cls: "claude-code-history-header collapsible-header" });
    const headerTitle = historyHeader.createEl("span", { cls: "collapsible-title" });
    headerTitle.createEl("span", { cls: "collapse-indicator", text: "\u25B6 " });
    headerTitle.appendText(t("history.title"));
    const clearHistoryBtn = historyHeader.createEl("button", {
      text: t("history.clearButton"),
      cls: "claude-code-clear-history"
    });
    clearHistoryBtn.addEventListener("click", (e) => {
      e.stopPropagation();
      onClearHistory();
    });
    const historyList = historySection.createEl("ul", { cls: "claude-code-history-list collapsible-content claude-code-hidden" });
    historySection.addClass("collapsed");
    headerTitle.addEventListener("click", () => {
      const isCollapsed = historyList.hasClass("claude-code-hidden");
      historyList.toggleClass("claude-code-hidden", !isCollapsed);
      const indicator = historyHeader.querySelector(".collapse-indicator");
      if (indicator) {
        indicator.textContent = isCollapsed ? "\u25BC " : "\u25B6 ";
      }
      historySection.toggleClass("collapsed", !isCollapsed);
    });
    return historyList;
  }
};

// src/ui/output-renderer.ts
var import_obsidian = require("obsidian");

// src/ui/parsers/agent-activity-parser.ts
var AgentActivityParser = class {
  /**
   * Parse and extract agent activity from output text
   *
   * @param text Output text to parse
   * @returns AgentStep object if activity detected, null otherwise
   */
  static parseAgentActivity(text) {
    if (text.includes("Resuming session:") || text.includes("\u2713 Resuming session:")) {
      return this.matchAndCreate(
        text,
        /(?: )?Resuming session: (.+)/,
        "\u{1F504}",
        "Resume",
        "resume",
        (match) => this.truncate(match[1], 8, false) + "..."
      );
    }
    if (text.includes("\u2192 Starting new session")) {
      return this.createStep("\u{1F195}", "New", "session started", "new-session");
    }
    if (text.includes("Vault access enabled:")) {
      return this.matchAndCreate(
        text,
        /Vault access enabled: (.+)/,
        "\u{1F5C2}\uFE0F",
        "Vault",
        "vault",
        (match) => this.extractFilename(match[1])
      );
    }
    if (text.includes("\u{1F527} Session initialized:")) {
      return this.matchAndCreate(
        text,
        / Session initialized: (.+)/,
        "\u{1F680}",
        "Initialize",
        "init"
      );
    }
    if (text.includes("\u{1F4BE} Session ID:")) {
      return this.matchAndCreate(
        text,
        / Session ID: (.+)/,
        "\u{1F4BE}",
        "Session",
        "session",
        (match) => this.truncate(match[1], 8, false) + "..."
      );
    }
    if (text.includes("\u{1F4E6} Available tools:")) {
      const match = text.match(/ Available tools: (.+)/);
      if (match) {
        const tools = match[1].split(", ");
        return this.createStep("\u{1F4E6}", "Tools", `${tools.length} available`, "tools");
      }
    }
    if (text.includes("\u{1F527} Using tool:")) {
      const match = text.match(/ Using tool: (\w+)/);
      if (match) {
        return this.createStep("\u{1F527}", match[1], "starting...", `tool-${match[1]}`);
      }
    }
    if (text.includes("$ ")) {
      return this.matchAndCreate(
        text,
        /\$ (.+)/,
        "\u26A1",
        "Bash",
        "bash",
        (match) => this.truncate(match[1], 60)
      );
    }
    if (text.includes("Query:") && (text.includes("\u{1F50D}") || text.includes("search"))) {
      return this.matchAndCreate(
        text,
        /(?: )?Query: "(.+?)"/,
        "\u{1F50D}",
        "Search",
        "search",
        (match) => this.truncate(match[1], 50)
      );
    }
    if (text.includes("\u{1F4E5} Tool result")) {
      return this.matchAndCreate(
        text,
        / Tool result \((.+?)\):/,
        "\u{1F4E5}",
        "Result",
        "result",
        (match) => this.truncate(match[1], 20)
      );
    }
    if (text.includes("\u{1F310} URL:")) {
      return this.matchAndCreate(
        text,
        / URL: (.+)/,
        "\u{1F310}",
        "Fetch",
        "fetch",
        (match) => this.truncate(match[1], 50)
      );
    }
    if (text.includes("\u{1F4D6}") && (text.includes("File:") || text.includes("Reading file:"))) {
      return this.matchAndCreate(
        text,
        /(?:File:|Reading file:)\s+(.+)/,
        "\u{1F4D6}",
        "Read",
        "read",
        (match) => this.extractFilename(match[1])
      );
    }
    if (text.includes("\u270D\uFE0F") && (text.includes("File:") || text.includes("Writing file:"))) {
      return this.matchAndCreate(
        text,
        /(?:File:|Writing file:)\s+(.+)/,
        "\u270D\uFE0F",
        "Write",
        "write",
        (match) => this.extractFilename(match[1])
      );
    }
    if (text.includes("\u270F\uFE0F") && (text.includes("File:") || text.includes("Editing file:"))) {
      return this.matchAndCreate(
        text,
        /(?:File:|Editing file:)\s+(.+)/,
        "\u270F\uFE0F",
        "Edit",
        "edit",
        (match) => this.extractFilename(match[1])
      );
    }
    if (text.includes("Pattern:")) {
      return this.matchAndCreate(
        text,
        /Pattern: (.+)/,
        "\u{1F50E}",
        "Search",
        "pattern",
        (match) => this.truncate(match[1], 40)
      );
    }
    if (text.includes("Agent:") || text.includes("Type:")) {
      return this.matchAndCreate(
        text,
        /(?:Agent:|Type:)\s+(.+)/,
        "\u{1F916}",
        "Agent",
        "agent"
      );
    }
    if (text.includes("\u2705 Complete!")) {
      return this.createStep("\u2705", "Complete", "Success", "complete");
    }
    if (text.includes("\u{1F4B0} Cost:")) {
      return this.matchAndCreate(
        text,
        / Cost: \$(\d+\.\d+)/,
        "\u{1F4B0}",
        "Cost",
        "cost",
        (match) => `$${match[1]}`
      );
    }
    if (text.includes("\u{1F4CA} Tokens:")) {
      const match = text.match(/ Tokens: (\d+) in, (\d+) out/);
      if (match) {
        return this.createStep("\u{1F4CA}", "Tokens", `${match[1]} \u2192 ${match[2]}`, "tokens");
      }
    }
    if (text.includes("\u23F1\uFE0F") && text.includes("Duration:")) {
      return this.matchAndCreate(
        text,
        /\s{2}Duration: (\d+)ms/,
        "\u23F1\uFE0F",
        "Duration",
        "duration",
        (match) => `${(parseInt(match[1]) / 1e3).toFixed(1)}s`
      );
    }
    if (text.includes("\u2713 Claude Code completed")) {
      return this.createStep("\u{1F389}", "Finished", "Successfully", "finished");
    }
    return null;
  }
  /**
   * Helper to create AgentStep from parameters
   */
  static createStep(icon, action, target, keyPrefix) {
    return {
      icon,
      action,
      target,
      key: `${keyPrefix}-${Date.now()}`
    };
  }
  /**
   * Helper to match pattern and create step with optional target transformation
   */
  static matchAndCreate(text, pattern, icon, action, keyPrefix, targetTransform) {
    const match = text.match(pattern);
    if (!match)
      return null;
    const target = targetTransform ? targetTransform(match) : match[1];
    return this.createStep(icon, action, target, keyPrefix);
  }
  /**
   * Helper to extract filename from path
   */
  static extractFilename(path7, maxLength = 40) {
    const filename = path7.split("/").pop() || path7;
    return filename.substring(0, maxLength);
  }
  /**
   * Helper to truncate text
   */
  static truncate(text, maxLength, addEllipsis = true) {
    if (text.length <= maxLength)
      return text;
    return addEllipsis ? text.substring(0, maxLength) + "..." : text.substring(0, maxLength);
  }
};

// src/ui/output-renderer.ts
var OutputRenderer = class {
  constructor(outputArea, component, app, notePath, outputSection) {
    this.outputSection = null;
    this.currentStreamingElement = null;
    this.outputArea = outputArea;
    this.component = component;
    this.app = app;
    this.notePath = notePath;
    this.currentStreamingElement = null;
    this.outputSection = outputSection || null;
  }
  /**
   * Update the note path for markdown rendering
   */
  setNotePath(notePath) {
    this.notePath = notePath;
  }
  /**
   * Append a line of output
   */
  appendLine(text, isMarkdown = false) {
    this.showOutputSection();
    const line = this.outputArea.createEl("div", { cls: "claude-code-output-line" });
    if (isMarkdown) {
      line.classList.add("markdown-rendered");
      try {
        void import_obsidian.MarkdownRenderer.render(this.app, text, line, this.notePath, this.component);
      } catch (error) {
        console.error("[MARKDOWN RENDER ERROR]", error);
        line.textContent = text;
      }
    } else {
      line.textContent = text;
    }
    this.outputArea.scrollTop = this.outputArea.scrollHeight;
  }
  /**
   * Append streaming text (accumulates in the same element)
   */
  appendStreamingText(text) {
    this.showOutputSection();
    if (!this.currentStreamingElement) {
      this.currentStreamingElement = this.outputArea.createEl("div", {
        cls: "claude-code-output-line claude-code-streaming"
      });
    }
    this.currentStreamingElement.createEl("span", {
      cls: "streaming-text-chunk",
      text
    });
    this.outputArea.scrollTop = this.outputArea.scrollHeight;
  }
  /**
   * Finish the current streaming block
   */
  finishStreamingBlock() {
    this.currentStreamingElement = null;
  }
  /**
   * Clear all output
   */
  clear() {
    this.outputArea.empty();
    this.hideOutputSection();
  }
  /**
   * Show the output section
   */
  showOutputSection() {
    if (this.outputSection) {
      this.outputSection.removeClass("claude-code-hidden");
    }
  }
  /**
   * Hide the output section
   */
  hideOutputSection() {
    if (this.outputSection) {
      this.outputSection.addClass("claude-code-hidden");
    }
  }
  /**
   * Parse and extract agent activity from output text
   */
  static parseAgentActivity(text) {
    return AgentActivityParser.parseAgentActivity(text);
  }
};

// src/ui/agent-activity-tracker.ts
var AgentActivityTracker = class {
  constructor() {
    this.agentSteps = /* @__PURE__ */ new Map();
    this.agentStepsContainer = null;
    this.agentActivitySection = null;
    this.agentContainer = null;
    this.stepTimers = /* @__PURE__ */ new Map();
    this.stepStartTimes = /* @__PURE__ */ new Map();
  }
  /**
   * Initialize the tracker with DOM elements
   */
  initialize(agentActivitySection) {
    this.agentActivitySection = agentActivitySection;
    this.agentStepsContainer = agentActivitySection.querySelector("#claude-code-agent-steps");
    this.agentContainer = document.getElementById("claude-code-agent-container");
  }
  /**
   * Add or update an agent step
   */
  addStep(step) {
    if (!this.agentStepsContainer || !this.agentActivitySection)
      return;
    this.agentActivitySection.removeClass("claude-code-hidden");
    if (this.agentContainer) {
      this.agentContainer.removeClass("claude-code-hidden");
    }
    if (this.agentSteps.has(step.key)) {
      const existingEl = this.agentSteps.get(step.key);
      if (step.duration !== void 0) {
        this.stopStepTimer(step.key);
        const oldDuration = existingEl.querySelector(".agent-step-duration");
        if (oldDuration) {
          oldDuration.remove();
        }
        const durationText = this.formatDuration(step.duration);
        existingEl.createEl("span", {
          cls: "agent-step-duration agent-step-duration-complete",
          text: durationText
        });
      }
      return;
    }
    const stepEl = this.agentStepsContainer.createEl("div", {
      cls: "claude-code-agent-step"
    });
    stepEl.createEl("span", {
      cls: "agent-step-icon",
      text: step.icon
    });
    stepEl.createEl("span", {
      cls: "agent-step-action",
      text: step.action
    });
    stepEl.createEl("span", {
      cls: "agent-step-target",
      text: step.target
    });
    if (step.duration !== void 0) {
      const durationText = this.formatDuration(step.duration);
      stepEl.createEl("span", {
        cls: "agent-step-duration agent-step-duration-complete",
        text: durationText
      });
    } else if (step.startTime !== void 0) {
      const durationEl = stepEl.createEl("span", {
        cls: "agent-step-duration agent-step-duration-live",
        text: "0.0s"
      });
      this.startStepTimer(step.key, step.startTime, durationEl);
    }
    this.agentSteps.set(step.key, stepEl);
    this.agentStepsContainer.scrollTop = this.agentStepsContainer.scrollHeight;
  }
  /**
   * Start a live timer for a step
   */
  startStepTimer(key, startTime, durationEl) {
    this.stepStartTimes.set(key, startTime);
    const timer = setInterval(() => {
      const elapsed = Date.now() - startTime;
      const formatted = this.formatDuration(elapsed);
      durationEl.textContent = formatted;
    }, 100);
    this.stepTimers.set(key, timer);
  }
  /**
   * Stop the live timer for a step
   */
  stopStepTimer(key) {
    const timer = this.stepTimers.get(key);
    if (timer) {
      clearInterval(timer);
      this.stepTimers.delete(key);
    }
    this.stepStartTimes.delete(key);
  }
  /**
   * Clear all agent steps
   */
  clear() {
    for (const timer of this.stepTimers.values()) {
      clearInterval(timer);
    }
    this.stepTimers.clear();
    this.stepStartTimes.clear();
    if (this.agentStepsContainer) {
      this.agentStepsContainer.empty();
    }
    this.agentSteps.clear();
    if (this.agentActivitySection) {
      this.agentActivitySection.addClass("claude-code-hidden");
    }
  }
  /**
   * Restore agent steps from an array
   */
  restore(steps) {
    this.clear();
    for (const step of steps) {
      this.addStep(step);
    }
  }
  /**
   * Get all current steps
   */
  getSteps() {
    return Array.from(this.agentSteps.keys()).map((key) => {
      var _a;
      const [action, target] = key.split("-");
      const stepEl = this.agentSteps.get(key);
      const icon = ((_a = stepEl.querySelector(".agent-step-icon")) == null ? void 0 : _a.textContent) || "\u{1F527}";
      return { icon, action, target, key };
    });
  }
  /**
   * Format duration in a human-readable way
   */
  formatDuration(ms) {
    if (ms < 1e3) {
      return `${ms}ms`;
    } else if (ms < 6e4) {
      return `${(ms / 1e3).toFixed(1)}s`;
    } else {
      const minutes = Math.floor(ms / 6e4);
      const seconds = Math.floor(ms % 6e4 / 1e3);
      return `${minutes}m ${seconds}s`;
    }
  }
};

// src/managers/note-context-manager.ts
var fs4 = __toESM(require("fs"));
var path5 = __toESM(require("path"));
var crypto2 = __toESM(require("crypto"));

// src/core/claude-code-runner.ts
var fs3 = __toESM(require("fs"));
var path4 = __toESM(require("path"));
var import_string_decoder = require("string_decoder");

// src/core/streaming/tool-output-formatter.ts
var ToolOutputFormatter = class {
  /**
   * Format tool usage information from tool_use event or message block
   *
   * @param toolName Name of the tool being used
   * @param toolInput Input parameters for the tool
   * @param format Format style: 'compact' for message blocks, 'verbose' for events
   * @returns Array of formatted output lines
   */
  static formatToolUsage(toolName, toolInput, format = "compact") {
    const lines = [];
    if (format === "verbose") {
      lines.push(...this.formatVerboseHeader(toolName));
    }
    lines.push(...this.formatToolSpecificParams(toolName, toolInput, format));
    return lines;
  }
  /**
   * Format verbose header for tool_use events
   */
  static formatVerboseHeader(toolName) {
    const headers = {
      "Bash": "\n\u{1F527} Bash executing:\n",
      "Glob": "\n\u{1F50D} Glob searching:\n",
      "Grep": "\n\u{1F50E} Grep searching:\n",
      "Read": "\n\u{1F4D6} Reading file:\n",
      "Write": "\n\u270D\uFE0F  Writing file:\n",
      "Edit": "\n\u270F\uFE0F  Editing file:\n",
      "WebFetch": "\n\u{1F310} Fetching webpage:\n",
      "WebSearch": "\n\u{1F50D} Web searching:\n",
      "Task": "\n\u{1F916} Launching agent:\n"
    };
    return [headers[toolName] || `
\u{1F6E0}\uFE0F  ${toolName}:
`];
  }
  /**
   * Format tool-specific parameters
   */
  static formatToolSpecificParams(toolName, toolInput, format) {
    var _a, _b, _c;
    const lines = [];
    if (!toolInput) {
      return lines;
    }
    switch (toolName) {
      case "Bash":
        if (toolInput.command) {
          lines.push(`   $ ${toolInput.command}
`);
          if (toolInput.description) {
            lines.push(`   \u{1F4DD} ${toolInput.description}
`);
          }
        }
        break;
      case "WebSearch":
        if (toolInput.query) {
          const prefix = format === "compact" ? "   \u{1F50D} Query:" : "   Query:";
          lines.push(`${prefix} "${toolInput.query}"
`);
          if ((_a = toolInput.allowed_domains) == null ? void 0 : _a.length) {
            const label = format === "compact" ? "   \u2713 Allowed:" : "   Allowed domains:";
            lines.push(`${label} ${toolInput.allowed_domains.join(", ")}
`);
          }
          if ((_b = toolInput.blocked_domains) == null ? void 0 : _b.length) {
            const label = format === "compact" ? "   \u2717 Blocked:" : "   Blocked domains:";
            lines.push(`${label} ${toolInput.blocked_domains.join(", ")}
`);
          }
        }
        break;
      case "WebFetch":
        if (toolInput.url) {
          const prefix = format === "compact" ? "   \u{1F310} URL:" : "   URL:";
          lines.push(`${prefix} ${toolInput.url}
`);
          if (toolInput.prompt) {
            const label = format === "compact" ? "   \u{1F4CB} Task:" : "   Task:";
            const truncated = toolInput.prompt.substring(0, format === "compact" ? 100 : 150);
            const ellipsis = toolInput.prompt.length > (format === "compact" ? 100 : 150) ? "..." : "";
            lines.push(`${label} ${truncated}${ellipsis}
`);
          }
        }
        break;
      case "Glob":
        if (toolInput.pattern) {
          const prefix = format === "compact" ? "   \u{1F50D} Pattern:" : "   Pattern:";
          lines.push(`${prefix} ${toolInput.pattern}
`);
          if (toolInput.path) {
            const searchPath = format === "verbose" ? toolInput.path : toolInput.path;
            lines.push(`   \u{1F4C1} Path: ${searchPath}
`);
          } else if (format === "verbose") {
            lines.push(`   Path: .
`);
          }
        }
        break;
      case "Grep":
        if (toolInput.pattern) {
          const prefix = format === "compact" ? "   \u{1F50E} Pattern:" : "   Pattern:";
          lines.push(`${prefix} "${toolInput.pattern}"
`);
          if (toolInput.path) {
            const searchPath = format === "verbose" ? toolInput.path : toolInput.path;
            lines.push(`   \u{1F4C1} Path: ${searchPath}
`);
          } else if (format === "verbose") {
            lines.push(`   Path: .
`);
          }
          if (toolInput.output_mode) {
            const label = format === "compact" ? "   \u{1F4CA} Mode:" : "   Mode:";
            lines.push(`${label} ${toolInput.output_mode}
`);
          }
        }
        break;
      case "Read":
        if (toolInput.file_path) {
          const prefix = format === "compact" ? "   \u{1F4D6} File:" : "   ";
          lines.push(`${prefix}${toolInput.file_path}
`);
          if (format === "verbose" && (toolInput.offset || toolInput.limit)) {
            const start = toolInput.offset || 0;
            const end = toolInput.limit ? start + toolInput.limit : "EOF";
            lines.push(`   Lines: ${start} to ${end}
`);
          }
        }
        break;
      case "Write":
        if (toolInput.file_path) {
          const prefix = format === "compact" ? "   \u270D\uFE0F  File:" : "   ";
          lines.push(`${prefix}${toolInput.file_path}
`);
          const contentLength = ((_c = toolInput.content) == null ? void 0 : _c.length) || 0;
          const label = format === "compact" ? "   \u{1F4CF} Size:" : "   Size:";
          lines.push(`${label} ${contentLength} char${contentLength === 1 ? "" : "s"}
`);
        }
        break;
      case "Edit":
        if (toolInput.file_path) {
          const prefix = format === "compact" ? "   \u270F\uFE0F  File:" : "   ";
          lines.push(`${prefix}${toolInput.file_path}
`);
          if (format === "verbose" && toolInput.replace_all) {
            lines.push(`   Mode: Replace all occurrences
`);
          }
        }
        break;
      case "Task":
        if (toolInput.subagent_type) {
          const prefix = format === "compact" ? "   \u{1F916} Agent:" : "   Type:";
          lines.push(`${prefix} ${toolInput.subagent_type}
`);
        }
        if (toolInput.description) {
          lines.push(`   \u{1F4CB} Task: ${toolInput.description}
`);
        }
        if (format === "verbose" && toolInput.prompt) {
          const shortPrompt = toolInput.prompt.substring(0, 150);
          lines.push(`   Prompt: ${shortPrompt}${toolInput.prompt.length > 150 ? "..." : ""}
`);
        }
        break;
      case "TodoWrite": {
        const todoInputStr = JSON.stringify(toolInput, null, 2);
        lines.push(`   ${todoInputStr}
`);
        break;
      }
      default: {
        const inputStr = JSON.stringify(toolInput, null, 2);
        if (format === "compact") {
          const linesArr = inputStr.split("\n");
          if (linesArr.length > 10) {
            lines.push(`   ${linesArr.slice(0, 10).join("\n")}
   ...
`);
          } else {
            lines.push(`   ${inputStr}
`);
          }
        } else {
          if (inputStr.length > 300) {
            lines.push(`   ${inputStr.substring(0, 300)}...
`);
          } else {
            lines.push(`   ${inputStr}
`);
          }
        }
        break;
      }
    }
    return lines;
  }
  /**
   * Format tool result output
   *
   * @param toolName Name of the tool
   * @param result Result object from the tool
   * @returns Array of formatted output lines
   */
  static formatToolResult(toolName, result) {
    const lines = [];
    if (toolName === "Bash" && result && typeof result === "object") {
      const stdout = result.stdout;
      if (typeof stdout === "string") {
        const output = stdout.trim();
        if (output) {
          const outputLines = output.split("\n");
          lines.push(`   \u2713 Output (${outputLines.length} lines):
`);
          const preview = outputLines.slice(0, 3).join("\n");
          lines.push(`   ${preview}${outputLines.length > 3 ? "\n   ..." : ""}
`);
        } else {
          lines.push(`   \u2713 ${toolName} complete
`);
        }
      } else {
        lines.push(`   \u2713 ${toolName} complete
`);
      }
    } else if (result) {
      lines.push(`   \u2713 ${toolName} complete
`);
    }
    return lines;
  }
};

// src/core/streaming/stream-event-processor.ts
var StreamEventProcessor = class {
  /**
   * Process a single stream event and generate output
   *
   * @param event The stream event to process
   * @param sendOutput Callback to send output text
   * @param setSessionId Optional callback to store session ID
   */
  static processEvent(event, sendOutput, setSessionId) {
    switch (event.type) {
      case "system":
        this.handleSystemEvent(event, sendOutput, setSessionId);
        break;
      case "assistant":
        this.handleAssistantEvent(event, sendOutput);
        break;
      case "tool_use":
        this.handleToolUseEvent(event, sendOutput);
        break;
      case "user":
        this.handleUserEvent(event, sendOutput);
        break;
      case "result":
        this.handleResultEvent(event, sendOutput);
        break;
      case "stream_event":
        this.handleStreamEvent(event, sendOutput);
        break;
      default:
        this.handleUnknownEvent(event, sendOutput);
        break;
    }
  }
  /**
   * Handle system initialization events
   */
  static handleSystemEvent(event, sendOutput, setSessionId) {
    var _a;
    if (event.subtype === "init") {
      sendOutput(`
\u{1F527} Session initialized: ${event.model}
`);
      sendOutput(`\u{1F4E6} Available tools: ${((_a = event.tools) == null ? void 0 : _a.join(", ")) || "none"}
`);
      if (event.session_id && setSessionId) {
        setSessionId(event.session_id);
        sendOutput(`\u{1F4BE} Session ID: ${event.session_id}
`);
      }
    }
  }
  /**
   * Handle assistant message events
   */
  static handleAssistantEvent(event, sendOutput) {
    var _a;
    if ((_a = event.message) == null ? void 0 : _a.content) {
      for (const block of event.message.content) {
        if (block.type === "text" && block.text) {
          sendOutput(block.text, true, false, true);
        } else if (block.type === "tool_use" && block.name) {
          const toolName = block.name;
          const toolInput = block.input || {};
          sendOutput(`
\u{1F527} Using tool: ${toolName}
`);
          const formatted = ToolOutputFormatter.formatToolUsage(toolName, toolInput, "compact");
          for (const line of formatted) {
            sendOutput(line);
          }
        }
      }
    }
  }
  /**
   * Handle tool use events
   */
  static handleToolUseEvent(event, sendOutput) {
    const toolName = event.tool_name || "unknown";
    if (event.subtype === "input" && event.input) {
      const formatted = ToolOutputFormatter.formatToolUsage(toolName, event.input, "verbose");
      for (const line of formatted) {
        sendOutput(line);
      }
    } else if (event.subtype === "result") {
      const resultLines = ToolOutputFormatter.formatToolResult(toolName, event.result);
      for (const line of resultLines) {
        sendOutput(line);
      }
      if ((toolName === "Glob" || toolName === "Grep") && event.result) {
        const resultStr = typeof event.result === "string" ? event.result : JSON.stringify(event.result);
        const lines = resultStr.split("\n").filter((l) => l.trim());
        sendOutput(`   \u2713 Found ${lines.length} results
`);
      }
    }
  }
  /**
   * Handle user/tool result events
   */
  static handleUserEvent(event, sendOutput) {
    var _a;
    if ((_a = event.message) == null ? void 0 : _a.content) {
      for (const block of event.message.content) {
        if (block.type === "tool_result") {
          sendOutput(`
\u{1F4E5} Tool result (${block.tool_use_id}):
`);
          const content = typeof block.content === "string" ? block.content : JSON.stringify(block.content);
          const lines = content.split("\n");
          if (lines.length > 10) {
            sendOutput(`   ${lines.slice(0, 10).join("\n")}
`);
            sendOutput(`   ... (${lines.length - 10} more lines)
`);
          } else if (content.length > 500) {
            sendOutput(`   ${content.substring(0, 500)}...
`);
            sendOutput(`   (${content.length - 500} more characters)
`);
          } else {
            sendOutput(`   ${content}
`);
          }
        }
      }
    }
  }
  /**
   * Handle final result events
   */
  static handleResultEvent(event, sendOutput) {
    var _a;
    sendOutput(`
\u2705 Complete!
`);
    sendOutput(`\u23F1\uFE0F  Duration: ${event.duration_ms}ms
`);
    sendOutput(`\u{1F4B0} Cost: $${((_a = event.total_cost_usd) == null ? void 0 : _a.toFixed(4)) || "0.0000"}
`);
    if (event.usage) {
      sendOutput(`\u{1F4CA} Tokens: ${event.usage.input_tokens} in, ${event.usage.output_tokens} out
`);
    }
  }
  /**
   * Handle real-time streaming events
   */
  static handleStreamEvent(event, sendOutput) {
    var _a, _b;
    const streamEvent = event.event;
    if (!streamEvent)
      return;
    if (streamEvent.type === "content_block_delta") {
      if (((_a = streamEvent.delta) == null ? void 0 : _a.type) === "text_delta" && streamEvent.delta.text) {
        console.debug("[Stream Processor] Sending text delta as assistant message");
        sendOutput(streamEvent.delta.text, false, true, true);
      }
    } else if (streamEvent.type === "content_block_start") {
      if (((_b = streamEvent.content_block) == null ? void 0 : _b.type) === "text") {
        sendOutput(`
\u{1F4AC} Claude: `, false, false);
      }
    } else if (streamEvent.type === "content_block_stop") {
      sendOutput(`
`, false, "finish", true);
    }
  }
  /**
   * Handle unknown event types (debugging)
   */
  static handleUnknownEvent(event, sendOutput) {
    sendOutput(`
\u{1F50D} [${event.type}${event.subtype ? " / " + event.subtype : ""}]
`);
    const displayFields = ["session_id", "uuid", "duration_ms", "model", "is_error"];
    for (const field of displayFields) {
      const value = event[field];
      if (value !== void 0) {
        sendOutput(`   ${field}: ${String(value)}
`);
      }
    }
    if (event.message) {
      sendOutput(`   message: ${JSON.stringify(event.message).substring(0, 200)}...
`);
    }
  }
};

// src/core/session-manager.ts
var fs = __toESM(require("fs"));
var path = __toESM(require("path"));
var crypto = __toESM(require("crypto"));
var SessionManager = class {
  /**
   * Get or create session directory for a note
   *
   * @param notePath Path to the note file
   * @param vaultPath Path to the vault root
   * @param configDir Config directory name from Vault.configDir
   * @returns Session information
   */
  static getSessionInfo(notePath, vaultPath, configDir) {
    const noteHash = crypto.createHash("md5").update(notePath).digest("hex");
    const sessionDir = path.join(vaultPath, configDir, "claude-code-sessions", noteHash);
    if (!fs.existsSync(sessionDir)) {
      fs.mkdirSync(sessionDir, { recursive: true });
    }
    const sessionIdFile = path.join(sessionDir, "session_id.txt");
    let sessionId = null;
    let isNewSession = true;
    if (fs.existsSync(sessionIdFile)) {
      try {
        sessionId = fs.readFileSync(sessionIdFile, "utf8").trim();
        isNewSession = false;
      } catch (error) {
        console.warn("Error loading session ID:", error);
      }
    }
    return {
      sessionDir,
      sessionId,
      isNewSession
    };
  }
  /**
   * Save session ID to disk
   *
   * @param sessionDir Directory where session data is stored
   * @param sessionId Session ID to save
   */
  static saveSessionId(sessionDir, sessionId) {
    try {
      const sessionIdFile = path.join(sessionDir, "session_id.txt");
      fs.writeFileSync(sessionIdFile, sessionId);
    } catch (error) {
      console.error("Error saving session ID:", error);
      throw error;
    }
  }
  /**
   * Save conversation history
   *
   * @param sessionDir Directory where session data is stored
   * @param userPrompt User's prompt
   * @param assistantResponse Assistant's response
   */
  static saveConversationHistory(sessionDir, userPrompt, assistantResponse) {
    const historyFile = path.join(sessionDir, "conversation_history.json");
    try {
      let history = [];
      if (fs.existsSync(historyFile)) {
        history = JSON.parse(fs.readFileSync(historyFile, "utf8"));
      }
      history.push({
        role: "user",
        content: userPrompt,
        timestamp: new Date().toISOString()
      });
      history.push({
        role: "assistant",
        content: assistantResponse,
        timestamp: new Date().toISOString()
      });
      if (history.length > 20) {
        history = history.slice(-20);
      }
      fs.writeFileSync(historyFile, JSON.stringify(history, null, 2));
    } catch (error) {
      console.error("Error saving conversation history:", error);
      throw error;
    }
  }
};

// src/core/prompt-builder.ts
var path2 = __toESM(require("path"));
var PromptBuilder = class {
  /**
   * Build a complete prompt for Claude Code
   *
   * @param request The request containing note content and user prompt
   * @param sessionDir Session directory path
   * @param customSystemPrompt Optional custom system prompt
   * @param allowVaultAccess Whether vault access is enabled
   * @param bypassPermissions Whether to bypass permission requests
   * @returns Complete prompt string
   */
  static buildPrompt(request, sessionDir, customSystemPrompt, allowVaultAccess, bypassPermissions) {
    let prompt = "";
    if (customSystemPrompt) {
      prompt += customSystemPrompt + "\n\n";
    }
    if (request.conversationalMode) {
      prompt += this.buildConversationalModeInstructions();
      prompt += `Current note content (for reference only - DO NOT MODIFY):
---
${request.noteContent}
---

`;
      prompt += `USER QUESTION: ${request.userPrompt}

`;
      return prompt;
    }
    prompt += this.buildPermissionModeInstructions(bypassPermissions);
    prompt += this.buildContextInstructions(request, sessionDir, allowVaultAccess);
    prompt += `EDITING INSTRUCTIONS:
`;
    prompt += `- The note content is in: ${path2.join(sessionDir, "note.md")}
`;
    prompt += `- Use the Edit or Write tool to modify the file
`;
    prompt += `- After you make changes, confirm what you did

`;
    prompt += `USER REQUEST: ${request.userPrompt}

`;
    return prompt;
  }
  /**
   * Build conversational mode instructions
   */
  static buildConversationalModeInstructions() {
    return `\u{1F4AC} CONVERSATIONAL MODE
You are in conversational mode. This means:
- DO NOT use file editing tools (Write, Edit, NotebookEdit)
- DO NOT modify any files
- You can use Read, Grep, Bash, WebSearch, and other read-only tools
- Focus on answering the user's question or providing information
- The note content is provided for context only
- Respond directly in your message - no file modifications needed

`;
  }
  /**
   * Build permission mode instructions
   */
  static buildPermissionModeInstructions(bypassPermissions) {
    if (bypassPermissions) {
      return `\u{1F513} PERMISSION MODE: AUTONOMOUS
You have FULL AUTONOMY to use ALL tools without asking for permission.
- You can read, write, edit, and execute any files or commands
- You can use web search, bash commands, and any other tools freely
- You do NOT need to ask for user approval before taking actions
- Proceed directly with your tasks using whatever tools are necessary

`;
    } else {
      return `\u{1F512} PERMISSION MODE: INTERACTIVE
- When you need permission (according your system prompt and configuration), your response MUST include the text "REQUIRED_APPROVAL"
`;
    }
  }
  /**
   * Build context instructions
   */
  static buildContextInstructions(request, sessionDir, allowVaultAccess) {
    let instructions = `You are an intelligent assistant helping to edit a markdown note in Obsidian vault. Your responses must be on the language of the user prompt

`;
    instructions += `CURRENT NOTE INFORMATION:
`;
    instructions += `- File path: ${request.notePath}
`;
    instructions += `- File name: ${path2.basename(request.notePath)}
`;
    instructions += `- Working directory: ${sessionDir}
`;
    instructions += `- Note file in session: note.md (local copy)
`;
    if (allowVaultAccess && request.vaultPath) {
      instructions += `- Obsidian vault root: ${request.vaultPath}
`;
      instructions += `- You can access ALL vault files using absolute paths: ${request.vaultPath}/filename.md
`;
      instructions += `- To search vault files, use tools with path: ${request.vaultPath}
`;
    }
    instructions += `
`;
    return instructions;
  }
  /**
   * Build agent mode instructions
   */
  static buildAgentInstructions() {
    return `You are a powerful AI assistant with access to tools. USE THEM ACTIVELY.

IMPORTANT - INTERPRET USER INTENT:
1. If the user is asking a QUESTION or requesting ANALYSIS, simply respond conversationally.
2. If the user wants to EDIT/MODIFY the note, use the Edit or Write tool to modify note.md, then explain what you changed.

`;
  }
};

// src/core/cli-args-builder.ts
var CliArgsBuilder = class {
  /**
   * Build CLI arguments array
   *
   * @param config Configuration for CLI arguments
   * @returns Array of CLI arguments
   */
  static buildArgs(config) {
    const args = [];
    args.push("--print");
    args.push("--verbose");
    args.push("--output-format", "stream-json");
    args.push("--input-format", "stream-json");
    args.push("--replay-user-messages");
    args.push("--include-partial-messages");
    if (config.sessionId) {
      args.push("--resume", config.sessionId);
    }
    if (config.settings.enablePermissionlessMode || config.bypassPermissions) {
      args.push("--permission-mode", "bypassPermissions");
    } else {
      args.push("--permission-mode", "acceptEdits");
    }
    if (config.settings.allowVaultAccess && config.vaultPath) {
      args.push("--add-dir", config.vaultPath);
    }
    const modelToUse = config.runtimeModelOverride || config.settings.modelAlias;
    if (modelToUse) {
      args.push("--model", modelToUse);
    }
    return args;
  }
};

// src/core/process-spawner.ts
var import_child_process = require("child_process");
var fs2 = __toESM(require("fs"));
var path3 = __toESM(require("path"));
var os = __toESM(require("os"));
var ProcessSpawner = class {
  /**
   * Check if running on Windows
   */
  static isWindows() {
    return process.platform === "win32";
  }
  /**
   * Get the default shell for the current platform
   */
  static getDefaultShell() {
    if (this.isWindows()) {
      if (process.env.COMSPEC) {
        return process.env.COMSPEC;
      }
      return "cmd.exe";
    }
    return process.env.SHELL || "/bin/sh";
  }
  /**
   * Get the PATH separator for the current platform
   */
  static getPathSeparator() {
    return this.isWindows() ? ";" : ":";
  }
  /**
   * Get the shell name from a shell path (e.g., "/bin/zsh" -> "zsh")
   */
  static getShellName(shellPath) {
    return path3.basename(shellPath);
  }
  /**
   * Get environment variables as if running in a login shell
   * This loads variables from .zshrc, .bash_profile, etc. on Unix
   * On Windows, it uses process.env directly as Windows doesn't have shell profiles
   */
  static getShellEnvironment(onDebugOutput) {
    if (this.isWindows()) {
      if (onDebugOutput) {
        onDebugOutput(`[DEBUG] Windows detected, using process.env directly
`);
      }
      return { ...process.env };
    }
    try {
      const shell = process.env.SHELL || "/bin/sh";
      const shellName = this.getShellName(shell);
      const homeDir = os.homedir();
      if (onDebugOutput) {
        onDebugOutput(`[DEBUG] Loading environment from shell: ${shell} (${shellName})
`);
        onDebugOutput(`[DEBUG] Home directory: ${homeDir}
`);
      }
      const startTime = Date.now();
      let sourceCommand;
      if (shellName === "zsh") {
        if (onDebugOutput) {
          onDebugOutput(`[DEBUG] Will source: ~/.zshenv, ~/.zprofile, ~/.zshrc
`);
        }
        sourceCommand = `${shell} -c 'source ~/.zshenv 2>/dev/null; source ~/.zprofile 2>/dev/null; source ~/.zshrc 2>/dev/null; env'`;
      } else if (shellName === "bash") {
        if (onDebugOutput) {
          onDebugOutput(`[DEBUG] Will source: ~/.profile, ~/.bash_profile, ~/.bashrc
`);
        }
        sourceCommand = `${shell} -c 'source ~/.profile 2>/dev/null; source ~/.bash_profile 2>/dev/null; source ~/.bashrc 2>/dev/null; env'`;
      } else if (shellName === "fish") {
        if (onDebugOutput) {
          onDebugOutput(`[DEBUG] Will source: fish config via login shell
`);
        }
        sourceCommand = `${shell} -l -c 'env'`;
      } else {
        if (onDebugOutput) {
          onDebugOutput(`[DEBUG] Using login shell fallback for: ${shellName}
`);
        }
        sourceCommand = `${shell} -l -c 'env'`;
      }
      const envOutput = (0, import_child_process.execSync)(sourceCommand, {
        encoding: "utf8",
        maxBuffer: 10 * 1024 * 1024,
        // 10MB buffer for large environments
        timeout: 5e3,
        // 5 second timeout
        env: { ...process.env, HOME: homeDir }
        // Ensure HOME is set
      });
      const duration = Date.now() - startTime;
      if (onDebugOutput) {
        onDebugOutput(`[DEBUG] Shell environment loaded in ${duration}ms
`);
        onDebugOutput(`[DEBUG] Raw output length: ${envOutput.length} bytes
`);
      }
      const env = {};
      const lines = envOutput.split("\n");
      if (onDebugOutput) {
        onDebugOutput(`[DEBUG] Parsing ${lines.length} lines of environment output
`);
      }
      lines.forEach((line) => {
        const idx = line.indexOf("=");
        if (idx > 0) {
          const key = line.substring(0, idx);
          const value = line.substring(idx + 1);
          env[key] = value;
        }
      });
      if (onDebugOutput) {
        onDebugOutput(`[DEBUG] Parsed ${Object.keys(env).length} environment variables
`);
        const processEnvKeys = Object.keys(process.env);
        const shellEnvKeys = Object.keys(env);
        const onlyInShell = shellEnvKeys.filter((k) => !processEnvKeys.includes(k));
        const onlyInProcess = processEnvKeys.filter((k) => !shellEnvKeys.includes(k));
        if (onlyInShell.length > 0) {
          onDebugOutput(`[DEBUG] Variables only in shell (${onlyInShell.length}): ${onlyInShell.slice(0, 10).join(", ")}${onlyInShell.length > 10 ? "..." : ""}
`);
        }
        if (onlyInProcess.length > 0) {
          onDebugOutput(`[DEBUG] Variables only in process.env (${onlyInProcess.length}): ${onlyInProcess.slice(0, 10).join(", ")}${onlyInProcess.length > 10 ? "..." : ""}
`);
        }
      }
      return env;
    } catch (error) {
      if (onDebugOutput) {
        onDebugOutput(`[DEBUG] \u26A0\uFE0F Failed to load shell environment: ${error}
`);
        onDebugOutput(`[DEBUG] Falling back to process.env
`);
      }
      return { ...process.env };
    }
  }
  /**
   * Spawn Claude Code process with enhanced environment
   *
   * @param config Spawn configuration
   * @returns Child process
   */
  static spawn(config) {
    const shellEnv = this.getShellEnvironment(config.onDebugOutput);
    if (config.customEnvVars) {
      const customVarCount = Object.keys(config.customEnvVars).filter((k) => config.customEnvVars[k]).length;
      if (customVarCount > 0 && config.onDebugOutput) {
        config.onDebugOutput(`[DEBUG] Applying ${customVarCount} custom environment variables:
`);
      }
      for (const [key, value] of Object.entries(config.customEnvVars)) {
        if (value) {
          shellEnv[key] = value;
          if (config.onDebugOutput) {
            const displayValue = key.includes("KEY") || key.includes("TOKEN") || key.includes("SECRET") ? `${value.substring(0, 8)}...` : value;
            config.onDebugOutput(`[DEBUG]   ${key}=${displayValue}
`);
          }
        }
      }
    }
    if (config.onDebugOutput) {
      config.onDebugOutput("[DEBUG] Shell environment variables loaded:\n");
      const sortedKeys = Object.keys(shellEnv).sort();
      const importantVars = ["PATH", "HOME", "SHELL", "USER", "ANTHROPIC_API_KEY", "NODE_ENV"];
      config.onDebugOutput("[DEBUG] Important variables:\n");
      for (const key of importantVars) {
        if (shellEnv[key]) {
          let value = shellEnv[key];
          if (key.includes("KEY") || key.includes("TOKEN") || key.includes("SECRET")) {
            value = value ? `${value.substring(0, 8)}...` : "";
          }
          config.onDebugOutput(`[DEBUG]   ${key}=${value}
`);
        }
      }
      config.onDebugOutput("[DEBUG] All environment variables:\n");
      for (const key of sortedKeys) {
        if (!importantVars.includes(key)) {
          let value = shellEnv[key];
          if (key.includes("KEY") || key.includes("TOKEN") || key.includes("SECRET") || key.includes("PASSWORD")) {
            value = value ? `${value.substring(0, 8)}...` : "";
          }
          config.onDebugOutput(`[DEBUG]   ${key}=${value}
`);
        }
      }
      config.onDebugOutput("\n");
    }
    let resolvedClaudePath = config.claudePath;
    if (resolvedClaudePath.startsWith("~")) {
      const homeDir = shellEnv.HOME || shellEnv.USERPROFILE || os.homedir();
      resolvedClaudePath = resolvedClaudePath.replace("~", homeDir);
    }
    if (!path3.isAbsolute(resolvedClaudePath)) {
      const pathSeparator = this.getPathSeparator();
      const pathDirs = (shellEnv.PATH || "").split(pathSeparator).filter((dir) => dir);
      const extensions = this.isWindows() ? ["", ".exe", ".cmd", ".bat"] : [""];
      for (const dir of pathDirs) {
        for (const ext of extensions) {
          const fullPath = path3.join(dir, resolvedClaudePath + ext);
          if (fs2.existsSync(fullPath)) {
            resolvedClaudePath = fullPath;
            break;
          }
        }
        if (path3.isAbsolute(resolvedClaudePath))
          break;
      }
    }
    if (config.onDebugOutput) {
      config.onDebugOutput(`[DEBUG] Resolved claude path: ${resolvedClaudePath}
`);
      config.onDebugOutput(`[DEBUG] Command: ${resolvedClaudePath} ${config.args.join(" ")}
`);
    }
    const shell = this.getDefaultShell();
    if (config.onDebugOutput) {
      config.onDebugOutput(`[DEBUG] Using shell: ${shell}
`);
      config.onDebugOutput(`[DEBUG] Platform: ${process.platform}
`);
    }
    const envWithUtf8 = {
      ...shellEnv,
      LANG: shellEnv.LANG || "en_US.UTF-8",
      LC_ALL: shellEnv.LC_ALL || "en_US.UTF-8",
      LC_CTYPE: shellEnv.LC_CTYPE || "en_US.UTF-8",
      PYTHONIOENCODING: "utf-8",
      // In case Claude CLI uses Python
      NODE_OPTIONS: shellEnv.NODE_OPTIONS ? `${shellEnv.NODE_OPTIONS} --input-type=module` : ""
    };
    const options = {
      cwd: config.workingDir,
      env: envWithUtf8,
      shell
    };
    const childProcess = (0, import_child_process.spawn)(resolvedClaudePath, config.args, options);
    if (childProcess.stdin) {
      childProcess.stdin.setDefaultEncoding("utf8");
    }
    return childProcess;
  }
  /**
   * Send stdin input to process
   *
   * @param process Child process
   * @param prompt Prompt to send
   */
  static sendInput(process2, prompt) {
    if (process2.stdin) {
      const inputMessage = {
        type: "user",
        message: {
          role: "user",
          content: prompt
        }
      };
      const jsonInput = JSON.stringify(inputMessage) + "\n";
      process2.stdin.write(jsonInput, "utf8");
      process2.stdin.end();
    }
  }
};

// src/core/response-parser.ts
var ResponseParser = class {
  /**
   * Parse JSON output lines from Claude Code
   *
   * @param outputLines Array of JSON output lines
   * @returns Parsed output with assistant text and token usage
   */
  static parseOutput(outputLines) {
    var _a, _b;
    let assistantText = "";
    let tokenUsage = void 0;
    for (const line of outputLines) {
      try {
        const event = JSON.parse(line);
        if (event.type === "stream_event") {
          if (event.event_type === "content_block_delta") {
            if (((_a = event.delta) == null ? void 0 : _a.type) === "text_delta" && event.delta.text) {
              assistantText += event.delta.text;
            }
          }
        }
        if (event.type === "assistant") {
          if ((_b = event.message) == null ? void 0 : _b.content) {
            for (const block of event.message.content) {
              if (block.type === "text") {
                assistantText += block.text + "\n";
              }
            }
          }
        }
        if (event.type === "result") {
          if (event.usage) {
            tokenUsage = {
              inputTokens: event.usage.input_tokens || 0,
              outputTokens: event.usage.output_tokens || 0,
              totalTokens: (event.usage.input_tokens || 0) + (event.usage.output_tokens || 0)
            };
          }
        }
      } catch (e) {
      }
    }
    return {
      assistantText: assistantText.trim(),
      tokenUsage
    };
  }
  /**
   * Build error response
   *
   * @param error Error message
   * @param outputLines Output lines (if any)
   * @returns Error response
   */
  static buildErrorResponse(error, outputLines = []) {
    return {
      success: false,
      error,
      output: outputLines
    };
  }
};

// src/core/streaming/response-content-extractor.ts
var ResponseContentExtractor = class {
  /**
   * Detect if Claude's response is asking for permission to perform an action
   *
   * @param text The text content to analyze
   * @returns True if the text contains a permission request pattern
   */
  static detectPermissionRequest(text) {
    return text.includes("REQUIRED_APPROVAL");
  }
};

// src/core/claude-code-runner.ts
var ClaudeCodeRunner = class {
  // Store session ID from init event
  constructor(settings) {
    this.currentProcess = null;
    this.outputCallback = null;
    this.currentSessionId = null;
    this.settings = settings;
  }
  /**
   * Run Claude Code with the given request
   */
  async run(request, onOutput) {
    this.outputCallback = onOutput || null;
    let claudePath = this.settings.claudeCodePath || "claude";
    if (claudePath.startsWith("~")) {
      const homeDir = process.env.HOME || process.env.USERPROFILE || "";
      claudePath = claudePath.replace("~", homeDir);
    }
    if (!claudePath) {
      return {
        success: false,
        error: "Claude Code path not configured. Please set it in plugin settings.",
        output: []
      };
    }
    try {
      return await this.executeClaudeCode(claudePath, request);
    } catch (error) {
      return {
        success: false,
        error: `Failed to execute Claude Code: ${error}`,
        output: []
      };
    }
  }
  /**
   * Execute Claude Code process and capture output
   */
  async executeClaudeCode(claudePath, request) {
    return new Promise((resolve) => {
      var _a, _b;
      const output = [];
      let errorOutput = "";
      const startTime = Date.now();
      const sessionInfo = SessionManager.getSessionInfo(
        request.notePath,
        request.vaultPath || "",
        request.configDir
      );
      this.sendOutput(
        sessionInfo.isNewSession ? `\u2192 Starting new session
` : `\u2713 Resuming session: ${sessionInfo.sessionId}
`
      );
      const noteFilePath = path4.join(sessionInfo.sessionDir, "note.md");
      const contentToEdit = request.selectedText || request.noteContent;
      try {
        fs3.writeFileSync(noteFilePath, contentToEdit, "utf8");
        this.sendOutput(`\u{1F4DD} Created note.md for editing
`);
      } catch (e) {
        this.sendOutput(`\u26A0\uFE0F Error creating note.md: ${e}
`);
      }
      const fullPrompt = PromptBuilder.buildPrompt(
        request,
        sessionInfo.sessionDir,
        this.settings.customSystemPrompt,
        this.settings.allowVaultAccess,
        this.settings.enablePermissionlessMode || request.bypassPermissions
      );
      const args = CliArgsBuilder.buildArgs({
        settings: this.settings,
        sessionId: sessionInfo.sessionId,
        vaultPath: request.vaultPath || null,
        bypassPermissions: request.bypassPermissions || false,
        runtimeModelOverride: request.runtimeModelOverride
      });
      if (this.settings.enablePermissionlessMode || request.bypassPermissions) {
        this.sendOutput(`\u{1F513} Permissionless mode enabled
`);
      } else {
        this.sendOutput(`\u{1F512} Permission mode: interactive (Claude will ask for permission)
`);
      }
      if (this.settings.allowVaultAccess && request.vaultPath) {
        this.sendOutput(`Vault access enabled: ${request.vaultPath}
`);
      }
      const workingDir = request.vaultPath || process.cwd();
      this.sendOutput(`Working dir: ${workingDir}
`);
      this.sendOutput(`Starting Claude Code...
`);
      this.sendOutput(`Session directory: ${sessionInfo.sessionDir}
`);
      this.sendOutput(`[DEBUG] Checking environment...
`);
      this.sendOutput(`[DEBUG] SHELL: ${process.env.SHELL}
`);
      this.sendOutput(`[DEBUG] HOME: ${process.env.HOME}
`);
      this.sendOutput(`[DEBUG] Claude path: ${claudePath}
`);
      const customEnvVars = {};
      if (this.settings.anthropicBaseUrl) {
        customEnvVars["ANTHROPIC_BASE_URL"] = this.settings.anthropicBaseUrl;
      }
      if (this.settings.anthropicAuthToken) {
        customEnvVars["ANTHROPIC_AUTH_TOKEN"] = this.settings.anthropicAuthToken;
      }
      if (this.settings.anthropicModel) {
        customEnvVars["ANTHROPIC_MODEL"] = this.settings.anthropicModel;
      }
      if (this.settings.anthropicSmallFastModel) {
        customEnvVars["ANTHROPIC_SMALL_FAST_MODEL"] = this.settings.anthropicSmallFastModel;
      }
      try {
        this.currentProcess = ProcessSpawner.spawn({
          claudePath,
          args,
          workingDir,
          onDebugOutput: (msg) => this.sendOutput(msg),
          customEnvVars: Object.keys(customEnvVars).length > 0 ? customEnvVars : void 0
        });
        this.sendOutput(`[DEBUG] Process spawned successfully, PID: ${this.currentProcess.pid}
`);
      } catch (spawnError) {
        this.sendOutput(`
\u274C Failed to spawn process: ${spawnError}`);
        throw spawnError;
      }
      ProcessSpawner.sendInput(this.currentProcess, fullPrompt);
      let timeoutId = null;
      if (this.settings.timeoutSeconds > 0) {
        timeoutId = setTimeout(() => {
          if (this.currentProcess) {
            this.sendOutput(`
Timeout after ${this.settings.timeoutSeconds} seconds, terminating...`);
            this.currentProcess.kill();
          }
        }, this.settings.timeoutSeconds * 1e3);
      }
      const stdoutDecoder = new import_string_decoder.StringDecoder("utf8");
      let buffer = "";
      (_a = this.currentProcess.stdout) == null ? void 0 : _a.on("data", (data) => {
        buffer += stdoutDecoder.write(data);
        const lines = buffer.split("\n");
        buffer = lines.pop() || "";
        for (const line of lines) {
          if (!line.trim())
            continue;
          try {
            const event = JSON.parse(line);
            output.push(line);
            this.handleStreamEvent(event);
          } catch (e) {
            this.sendOutput(`[raw] ${line}`);
          }
        }
      });
      const stderrDecoder = new import_string_decoder.StringDecoder("utf8");
      (_b = this.currentProcess.stderr) == null ? void 0 : _b.on("data", (data) => {
        const text = stderrDecoder.write(data);
        errorOutput += text;
        this.sendOutput(`[stderr] ${text}`);
      });
      this.sendOutput(`
[DEBUG] Process spawned, PID: ${this.currentProcess.pid}`);
      this.sendOutput(`[DEBUG] Working dir: ${workingDir}`);
      this.sendOutput(`[DEBUG] Session dir: ${sessionInfo.sessionDir}`);
      this.sendOutput(`[DEBUG] Waiting for output...
`);
      this.currentProcess.on("exit", (code, signal) => {
        this.sendOutput(`
[DEBUG] Process exited with code: ${code}, signal: ${signal}`);
      });
      this.currentProcess.on("close", (code) => {
        this.sendOutput(`
[DEBUG] Process closed with code: ${code}`);
        const claudeDir = path4.join(sessionInfo.sessionDir, ".claude");
        const claudeDirCreated = fs3.existsSync(claudeDir);
        this.sendOutput(`
[DEBUG] .claude directory after run: ${claudeDirCreated ? "EXISTS" : "NOT FOUND"}`);
        if (claudeDirCreated) {
          try {
            const contents = fs3.readdirSync(claudeDir);
            this.sendOutput(`
[DEBUG] .claude contents: ${contents.join(", ")}`);
          } catch (e) {
            this.sendOutput(`
[DEBUG] Error reading .claude: ${e}`);
          }
        }
        if (timeoutId) {
          clearTimeout(timeoutId);
        }
        this.currentProcess = null;
        if (code === 0) {
          this.sendOutput(`
[DEBUG] Processing ${output.length} output lines`);
          const parsed = ResponseParser.parseOutput(output);
          const isPermissionRequest = ResponseContentExtractor.detectPermissionRequest(parsed.assistantText);
          this.sendOutput(`
[DEBUG] Full response length: ${parsed.assistantText.length} chars`);
          let modifiedContent = void 0;
          try {
            if (fs3.existsSync(noteFilePath)) {
              const noteContent = fs3.readFileSync(noteFilePath, "utf8");
              if (noteContent !== contentToEdit && !request.conversationalMode) {
                modifiedContent = noteContent;
                this.sendOutput(`
\u2705 note.md was modified by Claude
`);
              } else {
                this.sendOutput(`
 \u2139\uFE0F  note.md unchanged (likely a question/analysis)
`);
              }
            } else {
              this.sendOutput(`
\u26A0\uFE0F  note.md not found after execution
`);
            }
          } catch (e) {
            this.sendOutput(`
\u26A0\uFE0F  Error reading note.md: ${e}
`);
          }
          try {
            SessionManager.saveConversationHistory(
              sessionInfo.sessionDir,
              request.userPrompt,
              parsed.assistantText
            );
            this.sendOutput(`
\u{1F4BE} Conversation history saved
`);
            if (this.currentSessionId) {
              SessionManager.saveSessionId(sessionInfo.sessionDir, this.currentSessionId);
              this.sendOutput(`\u{1F4BE} Session ID saved: ${this.currentSessionId}
`);
            }
          } catch (e) {
            this.sendOutput(`
\u26A0 Error saving session data: ${e}
`);
          }
          const totalDuration = Date.now() - startTime;
          const response = {
            success: true,
            modifiedContent,
            assistantMessage: parsed.assistantText,
            output,
            tokenUsage: parsed.tokenUsage,
            isPermissionRequest
          };
          if (response.success) {
            if (modifiedContent) {
              this.sendOutput(`
\u2713 Claude Code completed successfully in ${(totalDuration / 1e3).toFixed(2)}s`);
            } else if (isPermissionRequest) {
              this.sendOutput(`
\u26A0\uFE0F Permission request detected - waiting for user approval`);
            } else {
              this.sendOutput(`
\u2713 Analysis completed (no file modifications) in ${(totalDuration / 1e3).toFixed(2)}s`);
            }
          }
          resolve(response);
        } else {
          this.sendOutput(`
\u2717 Claude Code failed with code ${code}`);
          if (errorOutput) {
            this.sendOutput(`Error output: ${errorOutput}`);
          }
          resolve(ResponseParser.buildErrorResponse(
            `Claude Code exited with code ${code}. ${errorOutput}`,
            output
          ));
        }
      });
      this.currentProcess.on("error", (err) => {
        if (timeoutId) {
          clearTimeout(timeoutId);
        }
        this.currentProcess = null;
        this.sendOutput(`
\u2717 Error: ${err.message}`);
        resolve(ResponseParser.buildErrorResponse(
          `Failed to spawn Claude Code: ${err.message}`,
          output
        ));
      });
    });
  }
  /**
   * Send input to the current Claude Code process stdin
   */
  sendInput(input) {
    if (this.currentProcess && this.currentProcess.stdin) {
      try {
        this.currentProcess.stdin.write(input);
        this.sendOutput(`
[User input sent]: ${input.trim()}`);
        return true;
      } catch (error) {
        console.error("Failed to write to stdin:", error);
        this.sendOutput(`
\u2717 Failed to send input: ${error}`);
        return false;
      }
    }
    console.error("Cannot send input: no active process or stdin not available");
    return false;
  }
  /**
   * Terminate the current Claude Code process if running
   */
  terminate() {
    if (this.currentProcess) {
      this.currentProcess.kill();
      this.currentProcess = null;
      this.sendOutput("\n\u26A0 Process terminated by user");
    }
  }
  /**
   * Check if Claude Code is currently running
   */
  isRunning() {
    return this.currentProcess !== null;
  }
  /**
   * Handle stream-json events
   */
  handleStreamEvent(event) {
    StreamEventProcessor.processEvent(
      event,
      (text, isMarkdown, isStreaming, isAssistantMessage) => this.sendOutput(text, isMarkdown, isStreaming, isAssistantMessage),
      (sessionId) => {
        this.currentSessionId = sessionId;
      }
    );
  }
  /**
   * Send output to callback
   */
  sendOutput(text, isMarkdown = false, isStreaming, isAssistantMessage) {
    if (this.outputCallback) {
      this.outputCallback(text, isMarkdown, isStreaming, isAssistantMessage);
    }
  }
};

// src/managers/note-context-manager.ts
var NoteContextManager = class {
  constructor(settings, dataDir) {
    this.contexts = /* @__PURE__ */ new Map();
    this.settings = settings;
    this.dataDir = dataDir;
  }
  /**
   * Get or create context for a note
   */
  getContext(notePath) {
    if (!this.contexts.has(notePath)) {
      this.contexts.set(notePath, this.createNewContext());
    }
    return this.contexts.get(notePath);
  }
  /**
   * Create a new empty context
   */
  createNewContext() {
    return {
      history: [],
      sessionId: null,
      currentResponse: null,
      currentRequest: null,
      outputLines: [],
      agentSteps: [],
      runner: new ClaudeCodeRunner(this.settings),
      isRunning: false
    };
  }
  /**
   * Load all note contexts from disk
   */
  loadContexts(vaultPath) {
    var _a, _b, _c, _d;
    const contextsDir = path5.join(vaultPath, this.dataDir);
    if (!fs4.existsSync(contextsDir)) {
      return;
    }
    const noteDirs = fs4.readdirSync(contextsDir);
    for (const noteHash of noteDirs) {
      const contextFile = path5.join(contextsDir, noteHash, "context.json");
      if (fs4.existsSync(contextFile)) {
        try {
          const data = JSON.parse(fs4.readFileSync(contextFile, "utf8"));
          const context = {
            history: (_a = data.history) != null ? _a : [],
            sessionId: (_b = data.sessionId) != null ? _b : null,
            currentResponse: null,
            currentRequest: null,
            outputLines: (_c = data.outputLines) != null ? _c : [],
            agentSteps: (_d = data.agentSteps) != null ? _d : [],
            runner: new ClaudeCodeRunner(this.settings),
            isRunning: false,
            pendingPreviewContent: data.pendingPreviewContent,
            originalPreviewContent: data.originalPreviewContent
          };
          if (data.notePath) {
            this.contexts.set(data.notePath, context);
          }
        } catch (e) {
        }
      }
    }
  }
  /**
   * Save a note's context to disk
   */
  saveContext(notePath, vaultPath) {
    const context = this.contexts.get(notePath);
    if (!context)
      return;
    const noteHash = crypto2.createHash("md5").update(notePath).digest("hex");
    const contextDir = path5.join(vaultPath, this.dataDir, noteHash);
    if (!fs4.existsSync(contextDir)) {
      fs4.mkdirSync(contextDir, { recursive: true });
    }
    const contextFile = path5.join(contextDir, "context.json");
    const dataToSave = {
      notePath,
      sessionId: context.sessionId,
      history: context.history,
      outputLines: context.outputLines,
      agentSteps: context.agentSteps,
      pendingPreviewContent: context.pendingPreviewContent,
      originalPreviewContent: context.originalPreviewContent,
      savedAt: new Date().toISOString()
    };
    fs4.writeFileSync(contextFile, JSON.stringify(dataToSave, null, 2));
  }
  /**
   * Save all contexts
   */
  saveAllContexts(vaultPath) {
    for (const notePath of this.contexts.keys()) {
      this.saveContext(notePath, vaultPath);
    }
  }
  /**
   * Clear history for a note
   */
  clearHistory(notePath) {
    const context = this.contexts.get(notePath);
    if (context) {
      context.history = [];
      context.outputLines = [];
      context.agentSteps = [];
    }
  }
  /**
   * Get all contexts
   */
  getAllContexts() {
    return this.contexts;
  }
  /**
   * Check if a note has a context
   */
  hasContext(notePath) {
    return this.contexts.has(notePath);
  }
  /**
   * Get count of running processes
   */
  getRunningCount() {
    let count = 0;
    for (const context of this.contexts.values()) {
      if (context.isRunning) {
        count++;
      }
    }
    return count;
  }
  /**
   * Get list of note paths that are currently running
   */
  getRunningNotePaths() {
    const running = [];
    for (const [notePath, context] of this.contexts.entries()) {
      if (context.isRunning) {
        running.push(notePath);
      }
    }
    return running;
  }
};

// src/ui/parsers/output-status-manager.ts
var OutputStatusManager = class {
  /**
   * Parse an output line and extract status information
   *
   * @param line The output line to parse
   * @returns Status message to display, or null if no status should be shown
   */
  static extractStatus(line) {
    if (line.includes("\u{1F527} Using tool:")) {
      const toolMatch = line.match(/ Using tool: (\w+)/);
      if (toolMatch) {
        return `\u{1F527} Using ${toolMatch[1]} tool...`;
      }
    } else if (line.includes("$ ")) {
      const cmdMatch = line.match(/\$ (.+)/);
      if (cmdMatch) {
        const cmd = cmdMatch[1].substring(0, 50);
        return `\u26A1 Running: ${cmd}${cmdMatch[1].length > 50 ? "..." : ""}`;
      }
    } else if (line.includes("\u{1F50D} Query:") || line.includes("Query:")) {
      const queryMatch = line.match(/Query: "(.+?)"/);
      if (queryMatch) {
        const query = queryMatch[1].substring(0, 40);
        return `\u{1F50D} Searching: ${query}${queryMatch[1].length > 40 ? "..." : ""}`;
      }
    } else if (line.includes("\u{1F310} URL:") || line.includes("URL:")) {
      const urlMatch = line.match(/URL: (.+)/);
      if (urlMatch) {
        const url = urlMatch[1].substring(0, 40);
        return `\u{1F310} Fetching: ${url}${urlMatch[1].length > 40 ? "..." : ""}`;
      }
    } else if (line.includes("\u{1F4D6} Reading file:") || line.includes("\u{1F4D6} File:")) {
      const fileMatch = line.match(/(?:Reading file:|File:)\s+(.+)/);
      if (fileMatch) {
        const file = fileMatch[1].split("/").pop() || fileMatch[1];
        return `\u{1F4D6} Reading: ${file.substring(0, 40)}...`;
      }
    } else if (line.includes("\u270D\uFE0F  Writing file:") || line.includes("\u270D\uFE0F  File:")) {
      const fileMatch = line.match(/(?:Writing file:|File:)\s+(.+)/);
      if (fileMatch) {
        const file = fileMatch[1].split("/").pop() || fileMatch[1];
        return `\u270D\uFE0F Writing: ${file.substring(0, 40)}...`;
      }
    } else if (line.includes("\u270F\uFE0F  Editing file:") || line.includes("\u270F\uFE0F  File:")) {
      const fileMatch = line.match(/(?:Editing file:|File:)\s+(.+)/);
      if (fileMatch) {
        const file = fileMatch[1].split("/").pop() || fileMatch[1];
        return `\u270F\uFE0F Editing: ${file.substring(0, 40)}...`;
      }
    } else if (line.includes("\u{1F50D} Pattern:") || line.includes("Pattern:")) {
      const patternMatch = line.match(/Pattern: (.+)/);
      if (patternMatch) {
        const pattern = patternMatch[1].substring(0, 40);
        return `\u{1F50E} Searching pattern: ${pattern}${patternMatch[1].length > 40 ? "..." : ""}`;
      }
    } else if (line.includes("\u{1F916} Launching agent:") || line.includes("Agent:")) {
      const agentMatch = line.match(/(?:Agent:|Type:)\s+(.+)/);
      if (agentMatch) {
        return `\u{1F916} Launching ${agentMatch[1]} agent...`;
      }
    } else if (line.includes("\u{1F4AC}") && !line.includes("[raw]")) {
      return "\u{1F4AC} Claude is responding...";
    } else if (line.includes("\u2713") && line.includes("complete")) {
      return "\u2705 Processing results...";
    }
    return null;
  }
};

// src/ui/renderers/diff-generator.ts
var DiffGenerator = class {
  /**
   * Generate side-by-side diff view as a DOM element between original and modified content
   *
   * @param original Original content
   * @param modified Modified content
   * @returns HTMLElement representing the side-by-side diff
   */
  static generateDiffElement(original, modified) {
    const originalLines = original.split("\n");
    const modifiedLines = modified.split("\n");
    const diff = this.computeDiff(originalLines, modifiedLines);
    const container = document.createElement("div");
    container.className = "claude-code-diff-side-by-side";
    const header = document.createElement("div");
    header.className = "diff-header";
    const leftHeader = document.createElement("div");
    leftHeader.className = "diff-column diff-column-left";
    const leftTitle = document.createElement("span");
    leftTitle.className = "diff-header-title";
    leftTitle.textContent = t("diff.original");
    leftHeader.appendChild(leftTitle);
    const rightHeader = document.createElement("div");
    rightHeader.className = "diff-column diff-column-right";
    const rightTitle = document.createElement("span");
    rightTitle.className = "diff-header-title";
    rightTitle.textContent = t("diff.modified");
    rightHeader.appendChild(rightTitle);
    header.appendChild(leftHeader);
    header.appendChild(rightHeader);
    container.appendChild(header);
    const content = document.createElement("div");
    content.className = "diff-content";
    for (const change of diff) {
      const row = document.createElement("div");
      row.className = `diff-row diff-${change.type}`;
      if (change.type === "equal") {
        row.appendChild(this.createDiffColumn("left", change.oldLineNum, change.oldContent));
        row.appendChild(this.createDiffColumn("right", change.newLineNum, change.newContent));
      } else if (change.type === "delete") {
        row.appendChild(this.createDiffColumn("left", change.oldLineNum, change.oldContent));
        row.appendChild(this.createDiffColumn("right", void 0, void 0, true));
      } else if (change.type === "insert") {
        row.appendChild(this.createDiffColumn("left", void 0, void 0, true));
        row.appendChild(this.createDiffColumn("right", change.newLineNum, change.newContent));
      } else if (change.type === "modify") {
        row.appendChild(this.createDiffColumn("left", change.oldLineNum, change.oldContent));
        row.appendChild(this.createDiffColumn("right", change.newLineNum, change.newContent));
      }
      content.appendChild(row);
    }
    container.appendChild(content);
    return container;
  }
  /**
   * Create a diff column element
   */
  static createDiffColumn(side, lineNum, content, isEmpty = false) {
    const column = document.createElement("div");
    column.className = `diff-column diff-column-${side}${isEmpty ? " diff-empty" : ""}`;
    const lineNumSpan = document.createElement("span");
    lineNumSpan.className = "diff-line-number";
    lineNumSpan.textContent = lineNum !== void 0 ? String(lineNum) : "";
    const contentSpan = document.createElement("span");
    contentSpan.className = "diff-line-content";
    contentSpan.textContent = content || "";
    column.appendChild(lineNumSpan);
    column.appendChild(contentSpan);
    return column;
  }
  /**
   * Compute diff between two arrays of lines using a simple algorithm
   *
   * @param oldLines Original lines
   * @param newLines Modified lines
   * @returns Array of diff changes
   */
  static computeDiff(oldLines, newLines) {
    const result = [];
    let oldIndex = 0;
    let newIndex = 0;
    let oldLineNum = 1;
    let newLineNum = 1;
    while (oldIndex < oldLines.length || newIndex < newLines.length) {
      if (oldIndex >= oldLines.length) {
        result.push({
          type: "insert",
          newContent: newLines[newIndex],
          newLineNum
        });
        newIndex++;
        newLineNum++;
      } else if (newIndex >= newLines.length) {
        result.push({
          type: "delete",
          oldContent: oldLines[oldIndex],
          oldLineNum
        });
        oldIndex++;
        oldLineNum++;
      } else if (oldLines[oldIndex] === newLines[newIndex]) {
        result.push({
          type: "equal",
          oldContent: oldLines[oldIndex],
          newContent: newLines[newIndex],
          oldLineNum,
          newLineNum
        });
        oldIndex++;
        newIndex++;
        oldLineNum++;
        newLineNum++;
      } else {
        result.push({
          type: "modify",
          oldContent: oldLines[oldIndex],
          newContent: newLines[newIndex],
          oldLineNum,
          newLineNum
        });
        oldIndex++;
        newIndex++;
        oldLineNum++;
        newLineNum++;
      }
    }
    return result;
  }
};

// src/ui/view.ts
var ClaudeCodeView = class extends import_obsidian2.ItemView {
  constructor(leaf, plugin) {
    super(leaf);
    this.currentResultStreamingElement = null;
    this.hitFinalContentMarker = false;
    this.userHasScrolled = false;
    this.lastRenderedText = "";
    // State
    this.currentNotePath = "";
    // Tool timing tracking
    this.toolStartTimes = /* @__PURE__ */ new Map();
    this.lastToolKey = null;
    // Execution timing tracking (interval is view-level, but start time is per-note in context)
    this.elapsedTimeInterval = null;
    // Event listener cleanup tracking
    this.eventListeners = [];
    this.promptInputKeydownHandler = null;
    this.plugin = plugin;
    this.contextManager = new NoteContextManager(
      this.plugin.settings,
      `${this.app.vault.configDir}/claude-code-sessions`
    );
    this.agentTracker = new AgentActivityTracker();
    this.registerEvent(
      this.app.workspace.on("active-leaf-change", () => {
        this.onActiveNoteChange();
      })
    );
  }
  getViewType() {
    return VIEW_TYPE_CLAUDE_CODE;
  }
  getDisplayText() {
    return "Claude Code";
  }
  getIcon() {
    return "bot";
  }
  async onOpen() {
    const container = this.containerEl.children[1];
    container.empty();
    container.addClass("claude-code-view");
    const vaultPath = this.app.vault.adapter.getBasePath();
    if (vaultPath) {
      this.contextManager.loadContexts(vaultPath);
    }
    const activeFile = this.app.workspace.getActiveFile();
    if (activeFile) {
      this.currentNotePath = activeFile.path;
    }
    this.buildUI(container);
    this.outputRenderer = new OutputRenderer(this.outputArea, this, this.app, this.currentNotePath, this.outputSection);
    if (this.currentNotePath) {
      this.loadNoteContext(this.currentNotePath);
    }
  }
  /**
   * Build the entire UI using modular components
   */
  buildUI(container) {
    this.currentNoteLabel = UIBuilder.buildHeader(container);
    this.updateCurrentNoteLabel();
    const inputElements = UIBuilder.buildInputSection(
      container,
      this.plugin.settings.autoAcceptChanges,
      () => void this.handleRunClaudeCode(),
      () => this.handleCancel()
    );
    this.promptInput = inputElements.promptInput;
    this.selectedTextOnlyCheckbox = inputElements.selectedTextOnlyCheckbox;
    this.autoAcceptCheckbox = inputElements.autoAcceptCheckbox;
    this.conversationalModeCheckbox = inputElements.conversationalModeCheckbox;
    this.modelSelect = inputElements.modelSelect;
    this.runButton = inputElements.runButton;
    this.cancelButton = inputElements.cancelButton;
    this.conversationalModeCheckbox.addEventListener("change", () => {
      const isConversational = this.conversationalModeCheckbox.checked;
      this.selectedTextOnlyCheckbox.disabled = isConversational;
      this.autoAcceptCheckbox.disabled = isConversational;
      if (isConversational) {
        this.selectedTextOnlyCheckbox.checked = false;
        this.autoAcceptCheckbox.checked = false;
      }
    });
    this.modelSelect.addEventListener("change", () => {
      const context = this.getCurrentContext();
      context.selectedModel = this.modelSelect.value;
    });
    this.promptInputKeydownHandler = (e) => {
      var _a, _b;
      if (e.key === "Enter" && !e.shiftKey && !e.ctrlKey && !e.metaKey) {
        e.preventDefault();
        void this.handleRunClaudeCode();
      } else if (e.key === "Enter" && (e.ctrlKey || e.metaKey)) {
        e.preventDefault();
        const start = (_a = this.promptInput.selectionStart) != null ? _a : 0;
        const end = (_b = this.promptInput.selectionEnd) != null ? _b : 0;
        const value = this.promptInput.value;
        this.promptInput.value = value.substring(0, start) + "\n" + value.substring(end);
        this.promptInput.selectionStart = this.promptInput.selectionEnd = start + 1;
      }
    };
    this.promptInput.addEventListener("keydown", this.promptInputKeydownHandler);
    UIBuilder.buildInteractivePromptSection(
      container,
      (response) => this.respondToPrompt(response)
    );
    const resultElements = UIBuilder.buildResultSection(container);
    this.resultArea = resultElements.resultArea;
    this.statusIndicator = resultElements.statusArea;
    this.statusText = resultElements.statusText;
    this.lastPromptArea = resultElements.lastPromptArea;
    this.setupSmartAutoScroll();
    const permissionElements = UIBuilder.buildPermissionApprovalSection(
      container,
      () => void this.handleApprovePermission(),
      () => this.handleDenyPermission()
    );
    this.permissionApprovalSection = permissionElements.permissionApprovalSection;
    const previewElements = UIBuilder.buildPreviewSection(
      container,
      () => this.handleApplyChanges(),
      () => this.handleRejectChanges()
    );
    this.previewArea = previewElements.previewArea;
    this.previewContentContainer = previewElements.previewContentContainer;
    UIBuilder.buildAgentSection(container);
    const activityColumn = container.querySelector(".claude-code-activity-column");
    if (activityColumn) {
      this.agentTracker.initialize(activityColumn);
    }
    const outputSectionResult = UIBuilder.buildOutputSection(container);
    this.outputArea = outputSectionResult.outputArea;
    this.outputSection = outputSectionResult.outputSection;
    this.historyList = UIBuilder.buildHistorySection(
      container,
      () => this.clearHistory()
    );
  }
  /**
   * Update the current note label
   */
  updateCurrentNoteLabel() {
    if (this.currentNotePath) {
      const fileName = this.currentNotePath.split("/").pop() || "Unknown";
      const context = this.contextManager.getContext(this.currentNotePath);
      const runningIndicator = context.isRunning ? " \u{1F504}" : "";
      this.currentNoteLabel.textContent = `\u{1F4DD} ${fileName}${runningIndicator}`;
    } else {
      this.currentNoteLabel.textContent = "\u{1F4DD} " + t("header.noNoteSelected");
    }
    this.updateRunningIndicator();
  }
  /**
   * Update the indicator showing how many other notes have running processes
   */
  updateRunningIndicator() {
    var _a, _b;
    const runningPaths = this.contextManager.getRunningNotePaths();
    const otherRunning = runningPaths.filter((p) => p !== this.currentNotePath);
    let indicator = (_a = this.currentNoteLabel.parentElement) == null ? void 0 : _a.querySelector(".claude-code-running-indicator");
    if (otherRunning.length > 0) {
      if (!indicator) {
        indicator = document.createElement("span");
        indicator.addClass("claude-code-running-indicator");
        (_b = this.currentNoteLabel.parentElement) == null ? void 0 : _b.appendChild(indicator);
      }
      const noteNames = otherRunning.map((p) => p.split("/").pop() || "Unknown").join(", ");
      indicator.textContent = ` (${otherRunning.length} other running)`;
      indicator.setAttribute("title", `Running: ${noteNames}`);
      indicator.removeClass("claude-code-hidden");
    } else if (indicator) {
      indicator.addClass("claude-code-hidden");
    }
  }
  /**
   * Handle active note change
   */
  onActiveNoteChange() {
    const activeFile = this.app.workspace.getActiveFile();
    if (activeFile && activeFile.path !== this.currentNotePath) {
      this.currentNotePath = activeFile.path;
      this.updateCurrentNoteLabel();
      this.loadNoteContext(this.currentNotePath);
    }
  }
  /**
   * Load context for a specific note
   */
  loadNoteContext(notePath) {
    var _a, _b, _c, _d;
    const context = this.contextManager.getContext(notePath);
    (_a = this.outputRenderer) == null ? void 0 : _a.setNotePath(notePath);
    (_b = this.outputRenderer) == null ? void 0 : _b.clear();
    for (const line of context.outputLines) {
      (_c = this.outputRenderer) == null ? void 0 : _c.appendLine(line);
    }
    this.agentTracker.restore(context.agentSteps);
    console.debug("[Load Note Context] Output lines count:", context.outputLines.length);
    console.debug("[Load Note Context] Agent steps count:", context.agentSteps.length);
    console.debug("[Load Note Context] isRunning:", context.isRunning);
    if (context.outputLines.length > 0) {
      this.parseTodosFromOutput();
    } else {
      console.debug("[Load Note Context] Clearing todo list - no output");
      this.clearTodoList();
    }
    this.updateHistoryDisplay(context.history);
    if (context.selectedModel !== void 0) {
      this.modelSelect.value = context.selectedModel;
    } else {
      this.modelSelect.value = this.plugin.settings.modelAlias;
    }
    if (context.lastPrompt) {
      this.showLastPrompt(context.lastPrompt);
    } else {
      this.hideLastPrompt();
    }
    if (context.isRunning) {
      this.runButton.disabled = true;
      this.runButton.textContent = t("input.runningButton");
      this.cancelButton.removeClass("claude-code-hidden");
      this.cancelButton.addClass("claude-code-inline-visible");
      this.resumeElapsedTimeTracking();
      if (context.currentResultText) {
        this.restoreStreamingResult(context.currentResultText);
      }
    } else {
      this.stopElapsedTimeTracking();
      this.runButton.disabled = false;
      this.runButton.textContent = t("input.runButton");
      this.cancelButton.addClass("claude-code-hidden");
      this.cancelButton.removeClass("claude-code-inline-visible");
      this.hideStatus();
      if (!context.currentResponse || !context.currentResponse.assistantMessage) {
        this.hideResult();
      } else {
        this.showResult(context.currentResponse.assistantMessage);
      }
    }
    if (context.pendingPreviewContent) {
      this.restorePreview(context.pendingPreviewContent, context.originalPreviewContent || "");
    } else {
      this.hidePreviewUI();
    }
    if (((_d = context.currentResponse) == null ? void 0 : _d.isPermissionRequest) && !context.isRunning) {
      this.showPermissionApprovalSection();
    } else {
      this.hidePermissionApprovalSection();
    }
  }
  /**
   * Get current note's context
   */
  getCurrentContext() {
    return this.contextManager.getContext(this.currentNotePath);
  }
  /**
   * Handle Run Claude Code button click
   */
  async handleRunClaudeCode() {
    const context = this.getCurrentContext();
    if (context.isRunning) {
      new import_obsidian2.Notice(t("notice.alreadyProcessing"));
      return;
    }
    const prompt = this.promptInput.value.trim();
    if (!prompt) {
      new import_obsidian2.Notice(t("notice.enterPrompt"));
      return;
    }
    this.resetScrollState();
    try {
      this.promptInput.value = "";
      const file = this.app.workspace.getActiveFile();
      if (!file) {
        new import_obsidian2.Notice(t("notice.noActiveNote"));
        return;
      }
      const leaves = this.app.workspace.getLeavesOfType("markdown");
      let activeView = null;
      for (const leaf of leaves) {
        const view = leaf.view;
        if (view.file && view.file.path === file.path) {
          activeView = view;
          break;
        }
      }
      if (!activeView && leaves.length > 0) {
        activeView = leaves[0].view;
      }
      if (!activeView || !activeView.editor) {
        new import_obsidian2.Notice(t("notice.noEditor"));
        return;
      }
      const editor = activeView.editor;
      const selectedText = editor.getSelection();
      const useSelectedTextOnly = this.selectedTextOnlyCheckbox.checked && selectedText;
      const noteContent = editor.getValue();
      const vaultPath = this.app.vault.adapter.getBasePath();
      if (!vaultPath) {
        new import_obsidian2.Notice(t("notice.noVaultPath"));
        return;
      }
      context.currentRequest = {
        noteContent,
        userPrompt: prompt,
        notePath: file.path,
        selectedText: useSelectedTextOnly ? selectedText : void 0,
        vaultPath,
        configDir: this.app.vault.configDir,
        runtimeModelOverride: this.modelSelect.value || void 0,
        conversationalMode: this.conversationalModeCheckbox.checked
      };
      this.runButton.disabled = true;
      this.runButton.textContent = t("input.runningButton");
      this.cancelButton.removeClass("claude-code-hidden");
      this.cancelButton.addClass("claude-code-inline-visible");
      context.outputLines = [];
      this.outputRenderer.clear();
      this.agentTracker.clear();
      this.clearTodoList();
      this.hidePreview();
      this.hideResult();
      this.resultArea.empty();
      this.currentResultStreamingElement = null;
      this.hitFinalContentMarker = false;
      context.currentResultText = void 0;
      this.showLastPrompt(prompt);
      this.showStatus("\u{1F914} " + t("status.processing") + "... 0.0s");
      this.startElapsedTimeTracking("\u{1F914} " + t("status.processing"));
      const runNotePath = file.path;
      context.isRunning = true;
      this.updateCurrentNoteLabel();
      const response = await context.runner.run(
        context.currentRequest,
        (line, isMarkdown, isStreaming, isAssistantMessage) => {
          this.appendOutputToNote(runNotePath, line, isMarkdown, isStreaming, isAssistantMessage);
          if (this.currentNotePath === runNotePath) {
            this.updateStatusFromOutput(line);
          }
        }
      );
      context.isRunning = false;
      context.currentResponse = response;
      context.executionStartTime = void 0;
      context.baseStatusMessage = void 0;
      this.hideStatus();
      this.runButton.disabled = false;
      this.runButton.textContent = t("input.runButton");
      this.cancelButton.addClass("claude-code-hidden");
      this.cancelButton.removeClass("claude-code-inline-visible");
      this.updateCurrentNoteLabel();
      if (response.success) {
        context.history.push({
          prompt,
          timestamp: new Date(),
          success: true,
          notePath: file.path,
          response,
          request: context.currentRequest,
          outputLines: context.outputLines
        });
        this.updateHistoryDisplay(context.history);
        try {
          this.contextManager.saveContext(file.path, vaultPath);
        } catch (error) {
          console.error("Failed to save context:", error);
        }
        if (response.modifiedContent && response.modifiedContent.trim()) {
          if (this.autoAcceptCheckbox.checked) {
            if (this.currentNotePath === runNotePath) {
              this.showStatus("\u2705 " + t("status.autoApplying"));
            }
            this.applyChangesToEditor(response.modifiedContent, editor);
            if (this.currentNotePath === runNotePath) {
              this.hideStatus();
            }
            new import_obsidian2.Notice("\u2713 " + t("notice.changesApplied"));
          } else {
            this.showPreview(response.modifiedContent, runNotePath);
          }
        } else {
          if (response.isPermissionRequest) {
            if (this.currentNotePath === runNotePath) {
              this.showPermissionApprovalSection();
              const resultSection = document.getElementById("claude-code-result-section");
              const hasStreamedContent = resultSection && resultSection.hasClass("claude-code-visible") && this.resultArea.children.length > 0;
              if (!hasStreamedContent && response.assistantMessage && response.assistantMessage.trim()) {
                this.showResult(response.assistantMessage);
              }
            }
            new import_obsidian2.Notice("\u26A0\uFE0F " + t("notice.permissionRequest"));
          } else {
            if (this.currentNotePath === runNotePath) {
              const resultSection = document.getElementById("claude-code-result-section");
              const hasStreamedContent = resultSection && resultSection.hasClass("claude-code-visible") && this.resultArea.children.length > 0;
              if (!hasStreamedContent && response.assistantMessage && response.assistantMessage.trim()) {
                this.showResult(response.assistantMessage);
                new import_obsidian2.Notice("\u2713 " + t("notice.completed"));
              } else if (hasStreamedContent) {
                new import_obsidian2.Notice("\u2713 " + t("notice.completed"));
              } else {
                new import_obsidian2.Notice("\u2713 " + t("notice.completedNoChanges"));
              }
            } else {
              new import_obsidian2.Notice("\u2713 " + t("notice.completed"));
            }
          }
        }
      } else {
        if (this.currentNotePath === runNotePath) {
          this.showErrorStatus("\u274C " + t("status.failed"));
        }
        new import_obsidian2.Notice(`\u2717 ${response.error || "Unknown error"}`);
        context.history.push({
          prompt,
          timestamp: new Date(),
          success: false,
          notePath: file.path,
          response,
          request: context.currentRequest
        });
        this.updateHistoryDisplay(context.history);
      }
    } catch (error) {
      context.isRunning = false;
      context.executionStartTime = void 0;
      context.baseStatusMessage = void 0;
      throw error;
    }
  }
  /**
   * Append output to a specific note's context
   */
  appendOutputToNote(notePath, text, isMarkdown = false, isStreaming = false, isAssistantMessage = false) {
    const context = this.contextManager.getContext(notePath);
    context.outputLines.push(text);
    if (isAssistantMessage && isStreaming === true) {
      context.currentResultText = (context.currentResultText || "") + text;
    }
    if (isStreaming !== true) {
      const agentStep = OutputRenderer.parseAgentActivity(text);
      if (agentStep) {
        context.agentSteps.push(agentStep);
      }
    }
    if (notePath === this.currentNotePath) {
      if (isStreaming === true) {
        this.outputRenderer.appendStreamingText(text);
        console.debug("[Append Output] isStreaming=true, isAssistantMessage=", isAssistantMessage);
        if (isAssistantMessage) {
          this.appendToResultUI(text);
        }
        return;
      } else if (isStreaming === "finish") {
        this.outputRenderer.finishStreamingBlock();
        if (isAssistantMessage) {
          this.finishResultStreaming();
        }
      } else if (isAssistantMessage && !isStreaming) {
        const hasStreamingContent = this.currentResultStreamingElement !== null || this.resultArea && this.resultArea.children.length > 0;
        if (!hasStreamingContent) {
          console.debug("[Append Output] Non-streaming assistant message, adding to result");
          this.showResultMarkdown(text);
        } else {
          console.debug("[Append Output] Non-streaming assistant message, but already have streaming content - skipping");
        }
      }
      this.outputRenderer.appendLine(text, isMarkdown);
      const agentStep = OutputRenderer.parseAgentActivity(text);
      if (agentStep) {
        if (this.isToolStart(text)) {
          const now = Date.now();
          this.toolStartTimes.set(agentStep.key, now);
          this.lastToolKey = agentStep.key;
          agentStep.startTime = now;
        } else if (this.isToolComplete(text)) {
          if (this.lastToolKey && this.toolStartTimes.has(this.lastToolKey)) {
            const startTime = this.toolStartTimes.get(this.lastToolKey);
            const duration = Date.now() - startTime;
            this.agentTracker.addStep({
              ...agentStep,
              key: this.lastToolKey,
              duration
            });
            this.toolStartTimes.delete(this.lastToolKey);
            this.lastToolKey = null;
            return;
          }
        }
        this.agentTracker.addStep(agentStep);
      }
    }
  }
  /**
   * Check if output line indicates a tool is starting
   */
  isToolStart(text) {
    return text.includes("\u{1F527} Using tool:") || text.includes("$ ") || text.includes("\u{1F50D} Glob searching:") || text.includes("\u{1F50E} Grep searching:") || text.includes("\u{1F4D6} Reading file:") || text.includes("\u270D\uFE0F  Writing file:") || text.includes("\u270F\uFE0F  Editing file:") || text.includes("\u{1F310} Fetching webpage:") || text.includes("\u{1F50D} Web searching:") || text.includes("\u{1F916} Launching agent:");
  }
  /**
   * Check if output line indicates a tool completed
   */
  isToolComplete(text) {
    return text.includes("\u2713 Found") || // Glob/Grep results
    text.includes("\u2713 Output") || // Bash output
    text.includes("complete") || // Generic completion
    text.includes("\u{1F4E5} Tool result");
  }
  /**
   * Update status based on output line
   */
  updateStatusFromOutput(line) {
    const status = OutputStatusManager.extractStatus(line);
    if (status) {
      this.showStatus(status);
    }
    if (line.includes("Using tool: TodoWrite") || line.includes("\u{1F527} Using tool: TodoWrite")) {
      setTimeout(() => this.parseTodosFromOutput(), 100);
    }
  }
  /**
   * Parse todos from the output lines
   */
  parseTodosFromOutput() {
    const context = this.getCurrentContext();
    console.debug("[Parse Todos] Total output lines:", context.outputLines.length);
    const todoWriteIndices = [];
    context.outputLines.forEach((line, index) => {
      if (line.includes("Using tool: TodoWrite")) {
        todoWriteIndices.push(index);
      }
    });
    console.debug("[Parse Todos] Found TodoWrite at indices:", todoWriteIndices);
    if (todoWriteIndices.length === 0) {
      console.debug("[Parse Todos] No TodoWrite found in output lines");
      return;
    }
    const lastTodoWriteIndex = todoWriteIndices[todoWriteIndices.length - 1];
    console.debug("[Parse Todos] Using last TodoWrite at index:", lastTodoWriteIndex);
    if (lastTodoWriteIndex + 1 < context.outputLines.length) {
      const jsonLine = context.outputLines[lastTodoWriteIndex + 1];
      console.debug("[Parse Todos] JSON line length:", jsonLine.length);
      console.debug("[Parse Todos] JSON line preview:", jsonLine.substring(0, 300));
      try {
        const jsonStr = jsonLine.trim();
        console.debug("[Parse Todos] Trimmed JSON length:", jsonStr.length);
        console.debug("[Parse Todos] First char:", jsonStr[0], "Last char:", jsonStr[jsonStr.length - 1]);
        const toolInput = JSON.parse(jsonStr);
        if (toolInput.todos && Array.isArray(toolInput.todos)) {
          console.debug("[Parse Todos] Found todos count:", toolInput.todos.length);
          console.debug("[Parse Todos] Todos:", JSON.stringify(toolInput.todos, null, 2));
          this.updateTodoList(toolInput.todos);
        } else {
          console.debug("[Parse Todos] No todos array found in parsed JSON");
          console.debug("[Parse Todos] Parsed object keys:", Object.keys(toolInput));
        }
      } catch (error) {
        console.error("[Parse Todos] Failed to parse todos JSON:", error);
        console.error("[Parse Todos] Error details:", error instanceof Error ? error.message : error);
        const jsonStr = jsonLine.trim();
        console.error("[Parse Todos] Full JSON string:", jsonStr);
      }
    }
  }
  /**
   * Show status indicator
   */
  showStatus(message) {
    const resultSection = document.getElementById("claude-code-result-section");
    if (resultSection) {
      resultSection.removeClass("claude-code-hidden");
      resultSection.addClass("claude-code-visible");
    }
    this.statusIndicator.removeClass("claude-code-hidden");
    this.statusIndicator.addClass("claude-code-flex-visible");
    this.resultArea.addClass("claude-code-hidden");
    this.resultArea.removeClass("claude-code-visible");
    this.statusText.textContent = message;
  }
  /**
   * Show error status without progress bar animation
   */
  showErrorStatus(message) {
    this.stopElapsedTimeTracking();
    const resultSection = document.getElementById("claude-code-result-section");
    if (resultSection) {
      resultSection.removeClass("claude-code-hidden");
      resultSection.addClass("claude-code-visible");
    }
    this.statusIndicator.removeClass("claude-code-hidden");
    this.statusIndicator.addClass("claude-code-flex-visible");
    this.resultArea.addClass("claude-code-hidden");
    this.resultArea.removeClass("claude-code-visible");
    this.statusText.textContent = message;
  }
  /**
   * Start elapsed time tracking (stores timing in per-note context)
   */
  startElapsedTimeTracking(baseMessage) {
    const context = this.getCurrentContext();
    context.executionStartTime = Date.now();
    context.baseStatusMessage = baseMessage || "\u{1F914} Claude is processing";
    this.stopElapsedTimeTracking();
    this.elapsedTimeInterval = setInterval(() => {
      const ctx = this.getCurrentContext();
      if (ctx.executionStartTime) {
        const elapsed = Date.now() - ctx.executionStartTime;
        const seconds = (elapsed / 1e3).toFixed(1);
        this.statusText.textContent = `${ctx.baseStatusMessage || "\u{1F914} Processing"}... ${seconds}s`;
      }
    }, 100);
  }
  /**
   * Resume elapsed time tracking for current note (used when switching back to a running note)
   */
  resumeElapsedTimeTracking() {
    const context = this.getCurrentContext();
    if (!context.executionStartTime || !context.isRunning) {
      return;
    }
    this.stopElapsedTimeTracking();
    this.elapsedTimeInterval = setInterval(() => {
      const ctx = this.getCurrentContext();
      if (ctx.executionStartTime) {
        const elapsed = Date.now() - ctx.executionStartTime;
        const seconds = (elapsed / 1e3).toFixed(1);
        this.statusText.textContent = `${ctx.baseStatusMessage || "\u{1F914} Processing"}... ${seconds}s`;
      }
    }, 100);
  }
  /**
   * Stop elapsed time tracking
   */
  stopElapsedTimeTracking() {
    if (this.elapsedTimeInterval) {
      clearInterval(this.elapsedTimeInterval);
      this.elapsedTimeInterval = null;
    }
  }
  /**
   * Hide status indicator
   */
  hideStatus() {
    this.stopElapsedTimeTracking();
    this.statusIndicator.addClass("claude-code-hidden");
    this.statusIndicator.removeClass("claude-code-flex-visible");
    if (this.resultArea.children.length > 0) {
      this.resultArea.removeClass("claude-code-hidden");
      this.resultArea.addClass("claude-code-visible");
      const resultSection = document.getElementById("claude-code-result-section");
      if (resultSection) {
        resultSection.removeClass("claude-code-hidden");
        resultSection.addClass("claude-code-visible");
      }
    }
  }
  /**
   * Show the last prompt that was sent
   */
  showLastPrompt(prompt) {
    const context = this.getCurrentContext();
    context.lastPrompt = prompt;
    this.lastPromptArea.empty();
    this.lastPromptArea.removeClass("claude-code-hidden");
    this.lastPromptArea.createEl("span", {
      cls: "claude-code-last-prompt-label",
      text: "\u{1F4AC} "
    });
    const displayPrompt = prompt.length > 200 ? prompt.substring(0, 200) + "..." : prompt;
    this.lastPromptArea.createEl("span", {
      cls: "claude-code-last-prompt-text",
      text: displayPrompt
    });
    if (prompt.length > 200) {
      this.lastPromptArea.setAttribute("title", prompt);
    }
  }
  /**
   * Hide the last prompt display
   */
  hideLastPrompt() {
    this.lastPromptArea.addClass("claude-code-hidden");
    this.lastPromptArea.empty();
  }
  /**
   * Show preview of changes
   * @param modifiedContent The modified content to preview
   * @param forNotePath Optional: the note path this preview belongs to (defaults to current note)
   */
  showPreview(modifiedContent, forNotePath) {
    var _a, _b;
    const targetNotePath = forNotePath || this.currentNotePath;
    const context = this.contextManager.getContext(targetNotePath);
    const originalContent = ((_a = context.currentRequest) == null ? void 0 : _a.selectedText) || ((_b = context.currentRequest) == null ? void 0 : _b.noteContent) || "";
    context.pendingPreviewContent = modifiedContent;
    context.originalPreviewContent = originalContent;
    if (targetNotePath !== this.currentNotePath) {
      return;
    }
    const previewSection = document.getElementById("claude-code-preview-section");
    if (previewSection) {
      previewSection.removeClass("claude-code-hidden");
      previewSection.addClass("claude-code-visible");
    }
    this.previewArea.empty();
    const oldRendered = this.previewContentContainer.querySelector(".claude-code-preview-rendered");
    if (oldRendered)
      oldRendered.remove();
    const oldDiff = this.previewContentContainer.querySelector(".claude-code-preview-diff");
    if (oldDiff)
      oldDiff.remove();
    const statsDiv = this.previewArea.createEl("div", { cls: "claude-code-preview-stats" });
    statsDiv.createEl("span", { text: `${t("preview.originalLabel")} ${originalContent.length} ${t("preview.charsLabel")}` });
    statsDiv.createEl("span", { text: ` \u2192 ${t("preview.modifiedLabel")} ${modifiedContent.length} ${t("preview.charsLabel")}` });
    statsDiv.createEl("span", { text: ` (${modifiedContent.length - originalContent.length >= 0 ? "+" : ""}${modifiedContent.length - originalContent.length})` });
    const previewContent = this.previewArea.createEl("pre", { cls: "claude-code-preview-content" });
    previewContent.createEl("code", { text: modifiedContent });
    this.previewArea.addClass("claude-code-hidden");
    const diffArea = this.previewContentContainer.createEl("div", {
      cls: "claude-code-preview-diff claude-code-visible"
    });
    const diffElement = this.generateDiffElement(originalContent, modifiedContent);
    diffArea.appendChild(diffElement);
    const renderedArea = this.previewContentContainer.createEl("div", {
      cls: "claude-code-preview-rendered claude-code-hidden"
    });
    void import_obsidian2.MarkdownRenderer.render(
      this.app,
      modifiedContent,
      renderedArea,
      this.currentNotePath,
      this
    );
  }
  /**
   * Hide preview and clear context state
   */
  hidePreview() {
    this.hidePreviewUI();
    const context = this.getCurrentContext();
    context.pendingPreviewContent = void 0;
    context.originalPreviewContent = void 0;
  }
  /**
   * Hide preview UI only (without clearing context state)
   * Used when switching notes to preserve each note's preview state
   */
  hidePreviewUI() {
    const previewSection = document.getElementById("claude-code-preview-section");
    if (previewSection) {
      previewSection.addClass("claude-code-hidden");
      previewSection.removeClass("claude-code-visible");
    }
  }
  /**
   * Restore preview from stored context state (used when switching notes)
   */
  restorePreview(modifiedContent, originalContent) {
    const previewSection = document.getElementById("claude-code-preview-section");
    if (previewSection) {
      previewSection.removeClass("claude-code-hidden");
      previewSection.addClass("claude-code-visible");
    }
    this.previewArea.empty();
    const oldRendered = this.previewContentContainer.querySelector(".claude-code-preview-rendered");
    if (oldRendered)
      oldRendered.remove();
    const oldDiff = this.previewContentContainer.querySelector(".claude-code-preview-diff");
    if (oldDiff)
      oldDiff.remove();
    const statsDiv = this.previewArea.createEl("div", { cls: "claude-code-preview-stats" });
    statsDiv.createEl("span", { text: `${t("preview.originalLabel")} ${originalContent.length} ${t("preview.charsLabel")}` });
    statsDiv.createEl("span", { text: ` \u2192 ${t("preview.modifiedLabel")} ${modifiedContent.length} ${t("preview.charsLabel")}` });
    statsDiv.createEl("span", { text: ` (${modifiedContent.length - originalContent.length >= 0 ? "+" : ""}${modifiedContent.length - originalContent.length})` });
    const previewContent = this.previewArea.createEl("pre", { cls: "claude-code-preview-content" });
    previewContent.createEl("code", { text: modifiedContent });
    this.previewArea.addClass("claude-code-hidden");
    const diffArea = this.previewContentContainer.createEl("div", {
      cls: "claude-code-preview-diff claude-code-visible"
    });
    const diffElement = this.generateDiffElement(originalContent, modifiedContent);
    diffArea.appendChild(diffElement);
    const renderedArea = this.previewContentContainer.createEl("div", {
      cls: "claude-code-preview-rendered claude-code-hidden"
    });
    void import_obsidian2.MarkdownRenderer.render(
      this.app,
      modifiedContent,
      renderedArea,
      this.currentNotePath,
      this
    );
  }
  /**
   * Restore streaming result from context (used when switching back to a running note)
   */
  restoreStreamingResult(text) {
    const resultSection = document.getElementById("claude-code-result-section");
    if (resultSection) {
      resultSection.removeClass("claude-code-hidden");
      resultSection.addClass("claude-code-visible");
    }
    this.resultArea.removeClass("claude-code-hidden");
    this.resultArea.addClass("claude-code-visible");
    this.resultArea.empty();
    this.currentResultStreamingElement = this.resultArea.createEl("div", {
      cls: "claude-code-result-streaming markdown-rendered"
    });
    this.currentResultStreamingElement.accumulatedText = text;
    this.lastRenderedText = "";
    this.hitFinalContentMarker = false;
    this.renderStreamingMarkdown(text);
    console.debug("[Restore Streaming Result] Restored text length:", text.length);
  }
  /**
   * Append text to result panel UI only (context update handled by appendOutputToNote)
   * Used for streaming assistant messages when the current note is active
   */
  appendToResultUI(text) {
    console.debug("[Append To Result UI] Called with text:", text.substring(0, 50));
    if (this.hitFinalContentMarker) {
      console.debug("[Append To Result UI] Already hit FINAL-CONTENT marker flag, ignoring chunk");
      return;
    }
    const resultSection = document.getElementById("claude-code-result-section");
    if (resultSection) {
      console.debug("[Append To Result UI] Showing result section");
      resultSection.removeClass("claude-code-hidden");
      resultSection.addClass("claude-code-visible");
    }
    this.resultArea.removeClass("claude-code-hidden");
    this.resultArea.addClass("claude-code-visible");
    if (!this.currentResultStreamingElement) {
      console.debug("[Append To Result UI] Creating streaming element");
      this.currentResultStreamingElement = this.resultArea.createEl("div", {
        cls: "claude-code-result-streaming markdown-rendered"
      });
      this.currentResultStreamingElement.accumulatedText = "";
    }
    const accumulatedText = this.currentResultStreamingElement.accumulatedText || "";
    if (accumulatedText.includes("---FINAL-CONTENT---")) {
      console.debug("[Append To Result UI] Found FINAL-CONTENT in existing text, cleaning up and setting flag");
      this.cleanupFinalContentFromStream();
      this.hitFinalContentMarker = true;
      return;
    }
    const combinedText = accumulatedText + text;
    if (combinedText.includes("---FINAL-CONTENT---")) {
      const finalContentIndex = combinedText.indexOf("---FINAL-CONTENT---");
      const textBeforeMarker = combinedText.substring(0, finalContentIndex);
      this.currentResultStreamingElement.accumulatedText = textBeforeMarker;
      this.renderStreamingMarkdown(textBeforeMarker);
      console.debug("[Append To Result UI] Hit FINAL-CONTENT marker, setting flag");
      this.hitFinalContentMarker = true;
      return;
    }
    this.currentResultStreamingElement.accumulatedText = combinedText;
    this.renderStreamingMarkdown(combinedText);
    console.debug("[Append To Result UI] Appended chunk, accumulated length:", combinedText.length);
    this.autoScrollResult();
  }
  /**
   * Render accumulated markdown text by detecting and rendering complete blocks
   * Appends complete paragraphs/blocks as independent chunks
   */
  renderStreamingMarkdown(text) {
    if (!this.currentResultStreamingElement)
      return;
    const newContent = text.substring(this.lastRenderedText.length);
    if (!newContent)
      return;
    const { completeBlocks, remainingText } = this.extractCompleteBlocks(newContent);
    if (completeBlocks.length > 0) {
      this.removeIncompletePlainText();
      for (const block of completeBlocks) {
        this.appendMarkdownBlock(block);
      }
      this.lastRenderedText = this.lastRenderedText + newContent.substring(0, newContent.length - remainingText.length);
    }
    if (remainingText) {
      this.appendPlainText(remainingText);
    }
  }
  /**
   * Extract complete markdown blocks from the new content
   * Returns blocks that are ready to be rendered and remaining incomplete text
   */
  extractCompleteBlocks(newContent) {
    const blocks = [];
    const paragraphs = newContent.split(/\n\n+/);
    if (paragraphs.length > 1) {
      for (let i = 0; i < paragraphs.length - 1; i++) {
        if (paragraphs[i].trim()) {
          blocks.push(paragraphs[i]);
        }
      }
      return {
        completeBlocks: blocks,
        remainingText: paragraphs[paragraphs.length - 1]
      };
    }
    return {
      completeBlocks: [],
      remainingText: newContent
    };
  }
  /**
   * Remove incomplete plain text from the last render
   * (will be re-added as part of complete block or new plain text)
   */
  removeIncompletePlainText() {
    if (!this.currentResultStreamingElement)
      return;
    const lastChild = this.currentResultStreamingElement.lastChild;
    if (lastChild && lastChild.nodeType === Node.TEXT_NODE) {
      this.currentResultStreamingElement.removeChild(lastChild);
    }
  }
  /**
   * Append a complete markdown block as an independent rendered chunk
   */
  appendMarkdownBlock(blockText) {
    if (!this.currentResultStreamingElement)
      return;
    const blockContainer = document.createElement("div");
    blockContainer.addClass("markdown-block");
    void import_obsidian2.MarkdownRenderer.render(
      this.app,
      blockText,
      blockContainer,
      this.currentNotePath,
      this
    ).catch((e) => {
      console.error("[Append Markdown Block] Error:", e);
      blockContainer.textContent = blockText;
    });
    this.currentResultStreamingElement.appendChild(blockContainer);
  }
  /**
   * Append plain text without any processing
   */
  appendPlainText(text) {
    if (!this.currentResultStreamingElement)
      return;
    const lastChild = this.currentResultStreamingElement.lastChild;
    if (lastChild && lastChild.nodeType === Node.TEXT_NODE) {
      lastChild.textContent = text;
    } else {
      const textNode = document.createTextNode(text);
      this.currentResultStreamingElement.appendChild(textNode);
    }
  }
  /**
   * Clean up FINAL-CONTENT marker and everything after it from the streaming element
   */
  cleanupFinalContentFromStream() {
    if (!this.currentResultStreamingElement)
      return;
    const fullText = this.currentResultStreamingElement.textContent || "";
    const finalContentIndex = fullText.indexOf("---FINAL-CONTENT---");
    if (finalContentIndex === -1)
      return;
    console.debug("[Cleanup FINAL-CONTENT] Removing marker and content after it");
    const textToKeep = fullText.substring(0, finalContentIndex).trim();
    this.currentResultStreamingElement.empty();
    this.currentResultStreamingElement.createEl("span", {
      cls: "streaming-text-chunk",
      text: textToKeep
    });
    console.debug("[Cleanup FINAL-CONTENT] Cleaned up, kept text length:", textToKeep.length);
  }
  /**
   * Show markdown content in result section (for non-streaming assistant messages)
   */
  showResultMarkdown(text) {
    console.debug("[Show Result Markdown] Called with text length:", text.length);
    let filteredText = text;
    const finalContentIndex = text.indexOf("---FINAL-CONTENT---");
    if (finalContentIndex !== -1) {
      filteredText = text.substring(0, finalContentIndex).trim();
      console.debug("[Show Result Markdown] Filtered FINAL-CONTENT, new length:", filteredText.length);
    }
    const resultSection = document.getElementById("claude-code-result-section");
    if (resultSection) {
      resultSection.removeClass("claude-code-hidden");
      resultSection.addClass("claude-code-visible");
    }
    this.resultArea.removeClass("claude-code-hidden");
    this.resultArea.addClass("claude-code-visible");
    const contentDiv = this.resultArea.createEl("div", {
      cls: "markdown-rendered"
    });
    void import_obsidian2.MarkdownRenderer.render(
      this.app,
      filteredText,
      contentDiv,
      this.currentNotePath,
      this
    ).catch((e) => {
      console.error("[Show Result Markdown] Render error:", e);
      contentDiv.textContent = filteredText;
    });
    this.resultArea.scrollTop = this.resultArea.scrollHeight;
  }
  /**
   * Setup smart auto-scroll detection on result area
   */
  setupSmartAutoScroll() {
    this.resultArea.addEventListener("scroll", () => {
      const { scrollTop, scrollHeight, clientHeight } = this.resultArea;
      const isNearBottom = scrollHeight - scrollTop - clientHeight < 50;
      if (!isNearBottom) {
        this.userHasScrolled = true;
      } else {
        this.userHasScrolled = false;
      }
    });
  }
  /**
   * Auto-scroll result area to bottom (only if user hasn't manually scrolled up)
   */
  autoScrollResult() {
    if (!this.userHasScrolled) {
      this.resultArea.scrollTop = this.resultArea.scrollHeight;
    }
  }
  /**
   * Reset scroll state (call when starting new request)
   */
  resetScrollState() {
    this.userHasScrolled = false;
    this.lastRenderedText = "";
  }
  /**
   * Finish the streaming result block
   */
  finishResultStreaming() {
    if (this.currentResultStreamingElement) {
      console.debug("[Finish Result Streaming] Cleaning up streaming state");
      const fullAccumulatedText = this.currentResultStreamingElement.fullText || "";
      if (fullAccumulatedText && fullAccumulatedText.length > this.lastRenderedText.length) {
        const unrenderedText = fullAccumulatedText.substring(this.lastRenderedText.length);
        if (unrenderedText.trim()) {
          console.debug("[Finish Result Streaming] Rendering final unrendered text:", unrenderedText.substring(0, 50));
          const lastChild = this.currentResultStreamingElement.lastChild;
          if (lastChild && lastChild.nodeType === Node.TEXT_NODE) {
            this.currentResultStreamingElement.removeChild(lastChild);
          }
          this.appendMarkdownBlock(unrenderedText);
        }
      } else {
        const lastChild = this.currentResultStreamingElement.lastChild;
        if (lastChild && lastChild.nodeType === Node.TEXT_NODE) {
          const remainingText = lastChild.textContent || "";
          if (remainingText.trim()) {
            this.currentResultStreamingElement.removeChild(lastChild);
            this.appendMarkdownBlock(remainingText);
          }
        }
      }
      this.currentResultStreamingElement.removeClass("claude-code-result-streaming");
      this.currentResultStreamingElement.addClass("markdown-rendered");
      this.currentResultStreamingElement = null;
    }
  }
  /**
   * Show result panel with Claude's response
   */
  showResult(message) {
    this.resultArea.empty();
    let filteredMessage = message;
    const finalContentIndex = message.indexOf("---FINAL-CONTENT---");
    if (finalContentIndex !== -1) {
      filteredMessage = message.substring(0, finalContentIndex).trim();
      console.debug("[Show Result] Filtered FINAL-CONTENT, original length:", message.length, "filtered length:", filteredMessage.length);
    }
    void import_obsidian2.MarkdownRenderer.render(
      this.app,
      filteredMessage,
      this.resultArea,
      this.currentNotePath,
      this
    );
    const resultSection = document.getElementById("claude-code-result-section");
    if (resultSection) {
      resultSection.removeClass("claude-code-hidden");
      resultSection.addClass("claude-code-visible");
    }
    this.statusIndicator.addClass("claude-code-hidden");
    this.statusIndicator.removeClass("claude-code-flex-visible");
    this.resultArea.removeClass("claude-code-hidden");
    this.resultArea.addClass("claude-code-visible");
  }
  /**
   * Hide result panel
   */
  hideResult() {
    this.resultArea.addClass("claude-code-hidden");
    this.resultArea.removeClass("claude-code-visible");
    this.resultArea.empty();
    if (this.statusIndicator.hasClass("claude-code-hidden")) {
      const resultSection = document.getElementById("claude-code-result-section");
      if (resultSection) {
        resultSection.addClass("claude-code-hidden");
        resultSection.removeClass("claude-code-visible");
      }
    }
  }
  /**
   * Show permission approval section
   */
  showPermissionApprovalSection() {
    if (this.permissionApprovalSection) {
      this.permissionApprovalSection.removeClass("claude-code-hidden");
      this.permissionApprovalSection.addClass("claude-code-visible");
    }
  }
  /**
   * Hide permission approval section
   */
  hidePermissionApprovalSection() {
    if (this.permissionApprovalSection) {
      this.permissionApprovalSection.addClass("claude-code-hidden");
      this.permissionApprovalSection.removeClass("claude-code-visible");
    }
  }
  /**
   * Handle approve permission button click
   */
  async handleApprovePermission() {
    const context = this.getCurrentContext();
    if (!context.currentRequest) {
      new import_obsidian2.Notice(t("misc.noPendingRequest"));
      return;
    }
    this.hidePermissionApprovalSection();
    const file = this.app.workspace.getActiveFile();
    if (!file) {
      new import_obsidian2.Notice(t("notice.noActiveNote"));
      return;
    }
    const leaves = this.app.workspace.getLeavesOfType("markdown");
    let activeView = null;
    for (const leaf of leaves) {
      const view = leaf.view;
      if (view.file && view.file.path === file.path) {
        activeView = view;
        break;
      }
    }
    if (!activeView || !activeView.editor) {
      new import_obsidian2.Notice(t("notice.noEditor"));
      return;
    }
    const editor = activeView.editor;
    const approvalPrompt = "Yes, I approve. You have permissionless mode enabled - please proceed with the action you were asking about. Don't hesitate to execute it.";
    const newRequest = {
      ...context.currentRequest,
      userPrompt: approvalPrompt,
      bypassPermissions: true,
      configDir: this.app.vault.configDir
    };
    this.runButton.disabled = true;
    this.runButton.textContent = t("input.runningButton");
    this.cancelButton.removeClass("claude-code-hidden");
    this.cancelButton.addClass("claude-code-inline-visible");
    this.outputRenderer.clear();
    this.hidePreview();
    this.hideResult();
    this.showStatus("\u{1F513} " + t("status.runningAuthorized") + " ... 0.0s");
    this.startElapsedTimeTracking("\u{1F513} " + t("status.runningAuthorized"));
    const runNotePath = file.path;
    context.isRunning = true;
    const response = await context.runner.run(
      newRequest,
      (line, isMarkdown, isStreaming, isAssistantMessage) => {
        this.appendOutputToNote(runNotePath, line, isMarkdown, isStreaming, isAssistantMessage);
        if (this.currentNotePath === runNotePath) {
          this.updateStatusFromOutput(line);
        }
      }
    );
    context.isRunning = false;
    context.currentResponse = response;
    context.executionStartTime = void 0;
    context.baseStatusMessage = void 0;
    this.hideStatus();
    this.runButton.disabled = false;
    this.runButton.textContent = t("input.runButton");
    this.cancelButton.addClass("claude-code-hidden");
    this.cancelButton.removeClass("claude-code-inline-visible");
    if (response.success) {
      context.history.push({
        prompt: approvalPrompt,
        timestamp: new Date(),
        success: true,
        notePath: file.path,
        response,
        request: newRequest,
        outputLines: context.outputLines
      });
      this.updateHistoryDisplay(context.history);
      const vaultPath = this.app.vault.adapter.getBasePath();
      this.contextManager.saveContext(file.path, vaultPath);
      if (response.modifiedContent && response.modifiedContent.trim()) {
        if (this.autoAcceptCheckbox.checked) {
          if (this.currentNotePath === runNotePath) {
            this.showStatus("\u2705 " + t("status.autoApplying"));
          }
          this.applyChangesToEditor(response.modifiedContent, editor);
          if (this.currentNotePath === runNotePath) {
            this.hideStatus();
          }
          new import_obsidian2.Notice("\u2713 " + t("notice.changesApplied"));
        } else {
          this.showPreview(response.modifiedContent, runNotePath);
        }
      } else {
        if (this.currentNotePath === runNotePath) {
          const resultSection = document.getElementById("claude-code-result-section");
          const hasStreamedContent = resultSection && resultSection.hasClass("claude-code-visible") && this.resultArea.children.length > 0;
          if (!hasStreamedContent && response.assistantMessage && response.assistantMessage.trim()) {
            this.showResult(response.assistantMessage);
            new import_obsidian2.Notice("\u2713 " + t("notice.completed"));
          } else if (hasStreamedContent) {
            new import_obsidian2.Notice("\u2713 " + t("notice.completed"));
          } else {
            new import_obsidian2.Notice("\u2713 " + t("notice.completedNoChanges"));
          }
        } else {
          new import_obsidian2.Notice("\u2713 " + t("notice.completed"));
        }
      }
    } else {
      if (this.currentNotePath === runNotePath) {
        this.showErrorStatus("\u274C " + t("status.failed"));
      }
      new import_obsidian2.Notice(`\u2717 Claude Code failed: ${response.error || "Unknown error"}`);
    }
  }
  /**
   * Handle deny permission button click
   */
  handleDenyPermission() {
    this.hidePermissionApprovalSection();
    new import_obsidian2.Notice(t("notice.permissionDenied"));
  }
  /**
   * Handle apply changes
   */
  handleApplyChanges() {
    var _a;
    const context = this.getCurrentContext();
    const contentToApply = context.pendingPreviewContent || ((_a = context.currentResponse) == null ? void 0 : _a.modifiedContent);
    if (!contentToApply) {
      new import_obsidian2.Notice("\u26A0 " + t("notice.noChangesToApply"));
      console.error("[Apply Changes] No modified content found in context");
      return;
    }
    const file = this.app.workspace.getActiveFile();
    if (!file) {
      new import_obsidian2.Notice("\u26A0 " + t("notice.noActiveFile"));
      console.error("[Apply Changes] No active file found");
      return;
    }
    const leaves = this.app.workspace.getLeavesOfType("markdown");
    let targetView = null;
    for (const leaf of leaves) {
      const view = leaf.view;
      if (view.file && view.file.path === file.path) {
        targetView = view;
        break;
      }
    }
    if (!targetView && leaves.length > 0) {
      targetView = leaves[0].view;
    }
    if (!targetView || !targetView.editor) {
      new import_obsidian2.Notice("\u26A0 " + t("notice.noEditor"));
      console.error("[Apply Changes] No markdown view or editor found");
      return;
    }
    try {
      this.applyChangesToEditor(contentToApply, targetView.editor);
      this.hidePreview();
      new import_obsidian2.Notice("\u2713 " + t("notice.changesAppliedSuccess"));
    } catch (error) {
      new import_obsidian2.Notice("\u2717 " + t("notice.failedApplyChanges"));
      console.error("[Apply Changes] Error:", error);
    }
  }
  /**
   * Apply changes to editor
   */
  applyChangesToEditor(content, editor) {
    var _a;
    const context = this.getCurrentContext();
    const cursorBefore = editor.getCursor();
    if ((_a = context.currentRequest) == null ? void 0 : _a.selectedText) {
      editor.replaceSelection(content);
    } else {
      editor.setValue(content);
    }
    if (this.plugin.settings.preserveCursorPosition) {
      editor.setCursor(cursorBefore);
    }
  }
  /**
   * Handle reject changes
   */
  handleRejectChanges() {
    this.hidePreview();
    new import_obsidian2.Notice(t("notice.changesRejected"));
  }
  /**
   * Handle cancel
   */
  handleCancel() {
    const context = this.getCurrentContext();
    context.runner.terminate();
    context.isRunning = false;
    context.executionStartTime = void 0;
    context.baseStatusMessage = void 0;
    this.runButton.disabled = false;
    this.runButton.textContent = t("input.runButton");
    this.cancelButton.addClass("claude-code-hidden");
    this.cancelButton.removeClass("claude-code-inline-visible");
    this.hideStatus();
    new import_obsidian2.Notice(t("notice.cancelled"));
  }
  /**
   * Respond to interactive prompt (placeholder for future use)
   */
  respondToPrompt(response) {
    console.debug("Interactive response:", response);
  }
  /**
   * Generate diff HTML between original and modified content
   */
  generateDiffElement(original, modified) {
    return DiffGenerator.generateDiffElement(original, modified);
  }
  /**
   * Update history display
   */
  updateHistoryDisplay(history) {
    this.historyList.empty();
    const historySection = document.getElementById("claude-code-history-section");
    if (history.length === 0) {
      if (historySection) {
        historySection.addClass("claude-code-hidden");
        historySection.removeClass("claude-code-visible");
      }
      return;
    }
    if (historySection) {
      historySection.removeClass("claude-code-hidden");
      historySection.addClass("claude-code-visible");
    }
    for (const item of history.slice().reverse()) {
      const li = this.historyList.createEl("li");
      const icon = item.success ? "\u2713" : "\u2717";
      const time = new Date(item.timestamp).toLocaleTimeString();
      li.createEl("span", { text: `${icon} ${time}`, cls: "history-time" });
      const displayPrompt = item.prompt.length > 100 ? item.prompt.substring(0, 100) + "..." : item.prompt;
      li.createEl("span", { text: displayPrompt, cls: "history-prompt" });
      li.addEventListener("click", () => this.restoreFromHistory(item));
      li.addClass("claude-code-cursor-pointer");
    }
  }
  /**
   * Restore state from a history item
   */
  restoreFromHistory(item) {
    var _a;
    const context = this.getCurrentContext();
    this.promptInput.value = item.prompt;
    if (item.outputLines && item.outputLines.length > 0) {
      this.outputRenderer.clear();
      for (const line of item.outputLines) {
        this.outputRenderer.appendLine(line);
      }
    }
    if (item.response) {
      context.currentResponse = item.response;
      if (item.response.assistantMessage && item.response.assistantMessage.trim()) {
        this.showResult(item.response.assistantMessage);
      }
    }
    if (item.request) {
      context.currentRequest = item.request;
    }
    if (item.success && ((_a = item.response) == null ? void 0 : _a.modifiedContent)) {
      this.showPreview(item.response.modifiedContent);
      new import_obsidian2.Notice(t("notice.historyRestoredWithChanges"));
    } else {
      this.hidePreview();
      new import_obsidian2.Notice(t("notice.historyRestored"));
    }
  }
  /**
   * Clear history
   */
  clearHistory() {
    this.contextManager.clearHistory(this.currentNotePath);
    this.updateHistoryDisplay([]);
    const historySection = document.getElementById("claude-code-history-section");
    if (historySection) {
      historySection.addClass("claude-code-hidden");
      historySection.removeClass("claude-code-visible");
    }
    new import_obsidian2.Notice(t("notice.historyCleared"));
  }
  /**
   * Clear the todo list display
   */
  clearTodoList() {
    const planColumn = document.querySelector(".claude-code-plan-column");
    const todoList = document.getElementById("claude-code-todo-list");
    const emptyPlan = document.getElementById("claude-code-empty-plan");
    console.debug("[Clear Todo List] Called");
    if (!todoList || !planColumn) {
      console.debug("[Clear Todo List] Elements not found");
      return;
    }
    todoList.empty();
    if (emptyPlan) {
      emptyPlan.addClass("claude-code-hidden");
    }
    todoList.addClass("claude-code-hidden");
    planColumn.addClass("claude-code-hidden");
    console.debug("[Clear Todo List] Plan column hidden");
  }
  /**
   * Update Claude's todo list display
   */
  updateTodoList(todos) {
    const agentContainer = document.getElementById("claude-code-agent-container");
    const planColumn = document.querySelector(".claude-code-plan-column");
    const todoList = document.getElementById("claude-code-todo-list");
    const emptyPlan = document.getElementById("claude-code-empty-plan");
    if (!agentContainer || !todoList || !planColumn)
      return;
    todoList.empty();
    if (todos.length === 0) {
      planColumn.addClass("claude-code-hidden");
      if (emptyPlan)
        emptyPlan.addClass("claude-code-hidden");
      todoList.addClass("claude-code-hidden");
      const agentStepsContainer = document.getElementById("claude-code-agent-steps");
      if (agentStepsContainer && agentStepsContainer.children.length === 0) {
        agentContainer.removeClass("is-visible");
        agentContainer.addClass("is-hidden");
      }
    } else {
      agentContainer.removeClass("is-hidden");
      agentContainer.addClass("is-visible");
      planColumn.removeClass("claude-code-hidden");
      planColumn.addClass("claude-code-flex-visible");
      if (emptyPlan)
        emptyPlan.addClass("claude-code-hidden");
      todoList.removeClass("claude-code-hidden");
      todoList.addClass("claude-code-flex-visible");
      for (const todo of todos) {
        const todoItem = todoList.createEl("div", { cls: "claude-code-todo-item" });
        let icon = "\u23F3";
        let statusClass = "pending";
        if (todo.status === "in_progress") {
          icon = "\u{1F504}";
          statusClass = "in-progress";
        } else if (todo.status === "completed") {
          icon = "\u2705";
          statusClass = "completed";
        }
        todoItem.createEl("span", {
          cls: `claude-code-todo-icon ${statusClass}`,
          text: icon
        });
        const text = todo.status === "in_progress" ? todo.activeForm : todo.content;
        todoItem.createEl("span", {
          cls: "claude-code-todo-content",
          text
        });
      }
    }
  }
  /**
   * Update settings
   */
  updateSettings() {
    this.autoAcceptCheckbox.checked = this.plugin.settings.autoAcceptChanges;
    this.modelSelect.value = this.plugin.settings.modelAlias;
  }
  async onClose() {
    if (this.promptInputKeydownHandler) {
      this.promptInput.removeEventListener("keydown", this.promptInputKeydownHandler);
      this.promptInputKeydownHandler = null;
    }
    for (const { element, event, handler } of this.eventListeners) {
      element.removeEventListener(event, handler);
    }
    this.eventListeners = [];
    const vaultPath = this.app.vault.adapter.getBasePath();
    if (vaultPath) {
      try {
        this.contextManager.saveAllContexts(vaultPath);
      } catch (error) {
        console.error("Failed to save contexts on close:", error);
      }
    }
  }
};

// src/core/settings.ts
var import_obsidian3 = require("obsidian");
var import_child_process2 = require("child_process");
var os2 = __toESM(require("os"));
var fs5 = __toESM(require("fs"));
var path6 = __toESM(require("path"));
var DEFAULT_SETTINGS = {
  claudeCodePath: "",
  autoDetectPath: true,
  modelAlias: "",
  customSystemPrompt: "",
  preserveCursorPosition: true,
  timeoutSeconds: 300,
  autoAcceptChanges: false,
  allowVaultAccess: true,
  enablePermissionlessMode: false,
  // Custom API configuration (empty = use default)
  anthropicBaseUrl: "",
  anthropicAuthToken: "",
  anthropicModel: "",
  anthropicSmallFastModel: "",
  // UI settings
  language: "en"
};
var ClaudeCodeSettingTab = class extends import_obsidian3.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    new import_obsidian3.Setting(containerEl).setName(t("settings.language")).setDesc(t("settings.languageDesc")).addDropdown((dropdown) => {
      const locales = getAvailableLocales();
      for (const locale of locales) {
        dropdown.addOption(locale.code, locale.name);
      }
      dropdown.setValue(getLocale()).onChange(async (value) => {
        this.plugin.settings.language = value;
        setLocale(value);
        await this.plugin.saveSettings();
        this.display();
        new import_obsidian3.Notice(t("misc.languageChanged"));
      });
    });
    new import_obsidian3.Setting(containerEl).setName(t("settings.autoDetectPath")).setDesc(t("settings.autoDetectPathDesc")).addToggle((toggle) => toggle.setValue(this.plugin.settings.autoDetectPath).onChange(async (value) => {
      this.plugin.settings.autoDetectPath = value;
      if (value) {
        const detectedPath = this.detectClaudeCodePath();
        if (detectedPath) {
          this.plugin.settings.claudeCodePath = detectedPath;
        }
      }
      await this.plugin.saveSettings();
      this.display();
    }));
    new import_obsidian3.Setting(containerEl).setName(t("settings.executablePath")).setDesc(t("settings.executablePathDesc")).addText((text) => text.setPlaceholder("/usr/local/bin/claude").setValue(this.plugin.settings.claudeCodePath).setDisabled(this.plugin.settings.autoDetectPath).onChange(async (value) => {
      this.plugin.settings.claudeCodePath = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian3.Setting(containerEl).setName(t("settings.testInstallation")).setDesc(t("settings.testInstallationDesc")).addButton((button) => button.setButtonText(t("settings.testButton")).onClick(() => {
      void this.testClaudeCode().then((result) => {
        if (result.success) {
          button.setButtonText("\u2713 " + t("settings.testWorking"));
          setTimeout(() => {
            button.setButtonText(t("settings.testButton"));
          }, 2e3);
        } else {
          button.setButtonText("\u2717 " + t("settings.testFailed"));
          setTimeout(() => {
            button.setButtonText(t("settings.testButton"));
          }, 2e3);
          new import_obsidian3.Notice(`${t("misc.testFailed")}: ${result.error}`);
        }
      });
    }));
    new import_obsidian3.Setting(containerEl).setName(t("settings.customPrompt")).setDesc(t("settings.customPromptDesc")).addTextArea((text) => {
      text.setPlaceholder(t("settings.customPromptPlaceholder")).setValue(this.plugin.settings.customSystemPrompt).onChange(async (value) => {
        this.plugin.settings.customSystemPrompt = value;
        await this.plugin.saveSettings();
      });
      text.inputEl.rows = 4;
      text.inputEl.cols = 50;
    });
    new import_obsidian3.Setting(containerEl).setName(t("settings.preserveCursor")).setDesc(t("settings.preserveCursorDesc")).addToggle((toggle) => toggle.setValue(this.plugin.settings.preserveCursorPosition).onChange(async (value) => {
      this.plugin.settings.preserveCursorPosition = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian3.Setting(containerEl).setName(t("settings.autoAcceptChanges")).setDesc(t("settings.autoAcceptChangesDesc")).addToggle((toggle) => toggle.setValue(this.plugin.settings.autoAcceptChanges).onChange(async (value) => {
      this.plugin.settings.autoAcceptChanges = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian3.Setting(containerEl).setName(t("settings.model")).setDesc(t("settings.modelDesc")).addDropdown((dropdown) => dropdown.addOption("", t("settings.modelDefault")).addOption("sonnet", t("settings.modelSonnet")).addOption("opus", t("settings.modelOpus")).addOption("haiku", t("settings.modelHaiku")).setValue(this.plugin.settings.modelAlias).onChange(async (value) => {
      this.plugin.settings.modelAlias = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian3.Setting(containerEl).setName(t("settings.vaultAccess")).setDesc(t("settings.vaultAccessDesc")).addToggle((toggle) => toggle.setValue(this.plugin.settings.allowVaultAccess).onChange(async (value) => {
      this.plugin.settings.allowVaultAccess = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian3.Setting(containerEl).setName(t("settings.permissionlessMode")).setDesc(t("settings.permissionlessModeDesc")).addToggle((toggle) => toggle.setValue(this.plugin.settings.enablePermissionlessMode).onChange(async (value) => {
      this.plugin.settings.enablePermissionlessMode = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian3.Setting(containerEl).setName(t("settings.timeout")).setDesc(t("settings.timeoutDesc")).addText((text) => text.setPlaceholder("300").setValue(String(this.plugin.settings.timeoutSeconds)).onChange(async (value) => {
      const num = parseInt(value);
      if (!isNaN(num) && num >= 0) {
        this.plugin.settings.timeoutSeconds = num;
        await this.plugin.saveSettings();
      }
    }));
    new import_obsidian3.Setting(containerEl).setName(t("settings.customApiConfig")).setDesc(t("settings.customApiConfigDesc")).setHeading();
    new import_obsidian3.Setting(containerEl).setName(t("settings.apiBaseUrl")).setDesc(t("settings.apiBaseUrlDesc")).addText((text) => text.setPlaceholder("https://api.anthropic.com").setValue(this.plugin.settings.anthropicBaseUrl).onChange(async (value) => {
      this.plugin.settings.anthropicBaseUrl = value.trim();
      await this.plugin.saveSettings();
    }));
    new import_obsidian3.Setting(containerEl).setName(t("settings.apiAuthToken")).setDesc(t("settings.apiAuthTokenDesc")).addText((text) => {
      text.setPlaceholder(t("settings.apiAuthTokenPlaceholder")).setValue(this.plugin.settings.anthropicAuthToken).onChange(async (value) => {
        this.plugin.settings.anthropicAuthToken = value.trim();
        await this.plugin.saveSettings();
      });
      text.inputEl.type = "password";
    });
    new import_obsidian3.Setting(containerEl).setName(t("settings.customModel")).setDesc(t("settings.customModelDesc")).addText((text) => text.setPlaceholder("claude-sonnet-4-20250514").setValue(this.plugin.settings.anthropicModel).onChange(async (value) => {
      this.plugin.settings.anthropicModel = value.trim();
      await this.plugin.saveSettings();
    }));
    new import_obsidian3.Setting(containerEl).setName(t("settings.customSmallModel")).setDesc(t("settings.customSmallModelDesc")).addText((text) => text.setPlaceholder("claude-haiku-3-5-20241022").setValue(this.plugin.settings.anthropicSmallFastModel).onChange(async (value) => {
      this.plugin.settings.anthropicSmallFastModel = value.trim();
      await this.plugin.saveSettings();
    }));
  }
  /**
   * Attempt to detect Claude Code installation path (cross-platform)
   */
  detectClaudeCodePath() {
    const isWindows = process.platform === "win32";
    const homeDir = process.env.HOME || process.env.USERPROFILE || os2.homedir();
    let possiblePaths = [];
    if (isWindows) {
      possiblePaths = [
        "claude",
        // If in PATH
        path6.join(homeDir, "AppData", "Local", "Programs", "claude", "claude.exe"),
        path6.join(homeDir, ".bun", "bin", "claude.exe"),
        "C:\\Program Files\\claude\\claude.exe"
      ];
    } else {
      possiblePaths = [
        "claude",
        // If in PATH
        "/usr/local/bin/claude",
        "/usr/bin/claude",
        path6.join(homeDir, ".local", "bin", "claude"),
        path6.join(homeDir, "bin", "claude"),
        path6.join(homeDir, ".bun", "bin", "claude")
      ];
    }
    for (const cmdPath of possiblePaths) {
      try {
        if (!cmdPath.includes("/") && !cmdPath.includes("\\")) {
          const whichCmd = isWindows ? "where" : "which";
          const result = (0, import_child_process2.execSync)(`${whichCmd} ${cmdPath}`, { encoding: "utf8" }).trim();
          if (result) {
            return result.split("\n")[0].trim();
          }
        } else {
          if (fs5.existsSync(cmdPath)) {
            return cmdPath;
          }
        }
      } catch (e) {
      }
    }
    return null;
  }
  /**
   * Test if Claude Code is accessible and working (cross-platform)
   */
  async testClaudeCode() {
    try {
      const cmdPath = this.plugin.settings.claudeCodePath || "claude";
      const isWindows = process.platform === "win32";
      const homeDir = process.env.HOME || process.env.USERPROFILE || os2.homedir();
      const pathSeparator = isWindows ? ";" : ":";
      const envPath = process.env.PATH || "";
      let pathsToAdd = [];
      if (isWindows) {
        pathsToAdd = [
          path6.join(homeDir, "AppData", "Local", "Programs", "nodejs"),
          path6.join(homeDir, ".bun", "bin"),
          "C:\\Program Files\\nodejs",
          "C:\\Program Files (x86)\\nodejs"
        ];
      } else {
        pathsToAdd = [
          path6.join(homeDir, ".nvm", "versions", "node", "v20.18.2", "bin"),
          path6.join(homeDir, ".bun", "bin"),
          "/usr/local/bin",
          "/usr/bin",
          "/bin"
        ];
      }
      const existingPaths = pathsToAdd.filter((p) => {
        try {
          return fs5.existsSync(p);
        } catch (e) {
          return false;
        }
      });
      const enhancedPath = [.../* @__PURE__ */ new Set([...existingPaths, ...envPath.split(pathSeparator)])].join(pathSeparator);
      return new Promise((resolve) => {
        (0, import_child_process2.exec)(`${cmdPath} --version`, {
          timeout: 5e3,
          env: {
            ...process.env,
            PATH: enhancedPath
          }
        }, (error, stdout, stderr) => {
          if (error) {
            resolve({ success: false, error: error.message });
          } else {
            resolve({ success: true });
          }
        });
      });
    } catch (e) {
      return { success: false, error: String(e) };
    }
  }
};

// src/main.ts
var ClaudeCodePlugin = class extends import_obsidian4.Plugin {
  async onload() {
    await this.loadSettings();
    initI18n(this.settings.language);
    this.registerView(
      VIEW_TYPE_CLAUDE_CODE,
      (leaf) => new ClaudeCodeView(leaf, this)
    );
    this.addRibbonIcon("bot", "Open Claude Code", () => {
      void this.activateView();
    });
    this.addCommand({
      id: "open-claude-code-view",
      name: "Open Claude Code panel",
      callback: () => {
        void this.activateView();
      }
    });
    this.addCommand({
      id: "run-claude-code-quick",
      name: "Quick run Claude Code (with default prompt)",
      callback: async () => {
        await this.activateView();
      }
    });
    this.addCommand({
      id: "run-claude-code-selection",
      name: "Run Claude Code on selected text",
      callback: async () => {
        await this.activateView();
        const leaves = this.app.workspace.getLeavesOfType(VIEW_TYPE_CLAUDE_CODE);
        if (leaves.length > 0) {
          const view = leaves[0].view;
          const checkbox = view.containerEl.querySelector('.claude-code-options input[type="checkbox"]');
          if (checkbox) {
            checkbox.checked = true;
          }
        }
      }
    });
    this.addSettingTab(new ClaudeCodeSettingTab(this.app, this));
  }
  onunload() {
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
    const leaves = this.app.workspace.getLeavesOfType(VIEW_TYPE_CLAUDE_CODE);
    leaves.forEach((leaf) => {
      const view = leaf.view;
      view.updateSettings();
    });
  }
  async activateView() {
    const { workspace } = this.app;
    let leaf = null;
    const leaves = workspace.getLeavesOfType(VIEW_TYPE_CLAUDE_CODE);
    if (leaves.length > 0) {
      leaf = leaves[0];
    } else {
      leaf = workspace.getRightLeaf(false);
      await (leaf == null ? void 0 : leaf.setViewState({ type: VIEW_TYPE_CLAUDE_CODE, active: true }));
    }
    if (leaf) {
      void workspace.revealLeaf(leaf);
    }
  }
};
